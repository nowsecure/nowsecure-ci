// Package platformapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package platformapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for LabAppConfigLevel.
const (
	Advanced LabAppConfigLevel = "advanced"
	Baseline LabAppConfigLevel = "baseline"
)

// Defines values for LabAppPlatform.
const (
	LabAppPlatformAndroid     LabAppPlatform = "android"
	LabAppPlatformFireos      LabAppPlatform = "fireos"
	LabAppPlatformHarmonyos   LabAppPlatform = "harmonyos"
	LabAppPlatformIos         LabAppPlatform = "ios"
	LabAppPlatformPlaystation LabAppPlatform = "playstation"
	LabAppPlatformRoku        LabAppPlatform = "roku"
	LabAppPlatformTizen       LabAppPlatform = "tizen"
	LabAppPlatformWeb         LabAppPlatform = "web"
	LabAppPlatformWebos       LabAppPlatform = "webos"
	LabAppPlatformXbox        LabAppPlatform = "xbox"
)

// Defines values for GetAccountUserParamsExcludeRole00.
const (
	GetAccountUserParamsExcludeRole00Admin GetAccountUserParamsExcludeRole00 = "admin"
)

// Defines values for GetAccountUserParamsExcludeRole01.
const (
	GetAccountUserParamsExcludeRole01Analyst GetAccountUserParamsExcludeRole01 = "analyst"
)

// Defines values for GetAccountUserParamsExcludeRole02.
const (
	GetAccountUserParamsExcludeRole02Qa GetAccountUserParamsExcludeRole02 = "qa"
)

// Defines values for GetAccountUserParamsExcludeRole03.
const (
	GetAccountUserParamsExcludeRole03Developer GetAccountUserParamsExcludeRole03 = "developer"
)

// Defines values for GetAccountUserParamsExcludeRole04.
const (
	GetAccountUserParamsExcludeRole04Exec GetAccountUserParamsExcludeRole04 = "exec"
)

// Defines values for GetAccountUserParamsExcludeRole05.
const (
	GetAccountUserParamsExcludeRole05Customer GetAccountUserParamsExcludeRole05 = "customer"
)

// Defines values for GetAccountUserParamsExcludeRole06.
const (
	GetAccountUserParamsExcludeRole06FreeTrial GetAccountUserParamsExcludeRole06 = "free-trial"
)

// Defines values for GetAccountUserParamsExcludeRole07.
const (
	GetAccountUserParamsExcludeRole07InternalAdmin GetAccountUserParamsExcludeRole07 = "internal-admin"
)

// Defines values for GetAccountUserParamsExcludeRole08.
const (
	GetAccountUserParamsExcludeRole08InternalReadonly GetAccountUserParamsExcludeRole08 = "internal-readonly"
)

// Defines values for GetAccountUserParamsExcludeRole09.
const (
	GetAccountUserParamsExcludeRole09InternalReadonlyLimited GetAccountUserParamsExcludeRole09 = "internal-readonly-limited"
)

// Defines values for GetAccountUserParamsExcludeRole010.
const (
	GetAccountUserParamsExcludeRole010InternalTam GetAccountUserParamsExcludeRole010 = "internal-tam"
)

// Defines values for GetAccountUserParamsExcludeRole011.
const (
	GetAccountUserParamsExcludeRole011InternalAnalystAll GetAccountUserParamsExcludeRole011 = "internal-analyst-all"
)

// Defines values for GetAccountUserParamsExcludeRole012.
const (
	GetAccountUserParamsExcludeRole012InternalAnalyst GetAccountUserParamsExcludeRole012 = "internal-analyst"
)

// Defines values for GetAccountUserParamsExcludeRole013.
const (
	GetAccountUserParamsExcludeRole013InternalReports GetAccountUserParamsExcludeRole013 = "internal-reports"
)

// Defines values for GetAccountUserParamsExcludeRole10.
const (
	GetAccountUserParamsExcludeRole10Admin GetAccountUserParamsExcludeRole10 = "admin"
)

// Defines values for GetAccountUserParamsExcludeRole11.
const (
	GetAccountUserParamsExcludeRole11Analyst GetAccountUserParamsExcludeRole11 = "analyst"
)

// Defines values for GetAccountUserParamsExcludeRole12.
const (
	GetAccountUserParamsExcludeRole12Qa GetAccountUserParamsExcludeRole12 = "qa"
)

// Defines values for GetAccountUserParamsExcludeRole13.
const (
	GetAccountUserParamsExcludeRole13Developer GetAccountUserParamsExcludeRole13 = "developer"
)

// Defines values for GetAccountUserParamsExcludeRole14.
const (
	GetAccountUserParamsExcludeRole14Exec GetAccountUserParamsExcludeRole14 = "exec"
)

// Defines values for GetAccountUserParamsExcludeRole15.
const (
	GetAccountUserParamsExcludeRole15Customer GetAccountUserParamsExcludeRole15 = "customer"
)

// Defines values for GetAccountUserParamsExcludeRole16.
const (
	GetAccountUserParamsExcludeRole16FreeTrial GetAccountUserParamsExcludeRole16 = "free-trial"
)

// Defines values for GetAccountUserParamsExcludeRole17.
const (
	GetAccountUserParamsExcludeRole17InternalAdmin GetAccountUserParamsExcludeRole17 = "internal-admin"
)

// Defines values for GetAccountUserParamsExcludeRole18.
const (
	GetAccountUserParamsExcludeRole18InternalReadonly GetAccountUserParamsExcludeRole18 = "internal-readonly"
)

// Defines values for GetAccountUserParamsExcludeRole19.
const (
	GetAccountUserParamsExcludeRole19InternalReadonlyLimited GetAccountUserParamsExcludeRole19 = "internal-readonly-limited"
)

// Defines values for GetAccountUserParamsExcludeRole110.
const (
	GetAccountUserParamsExcludeRole110InternalTam GetAccountUserParamsExcludeRole110 = "internal-tam"
)

// Defines values for GetAccountUserParamsExcludeRole111.
const (
	GetAccountUserParamsExcludeRole111InternalAnalystAll GetAccountUserParamsExcludeRole111 = "internal-analyst-all"
)

// Defines values for GetAccountUserParamsExcludeRole112.
const (
	GetAccountUserParamsExcludeRole112InternalAnalyst GetAccountUserParamsExcludeRole112 = "internal-analyst"
)

// Defines values for GetAccountUserParamsExcludeRole113.
const (
	GetAccountUserParamsExcludeRole113InternalReports GetAccountUserParamsExcludeRole113 = "internal-reports"
)

// Defines values for GetAppParamsPlatform.
const (
	GetAppParamsPlatformAndroid     GetAppParamsPlatform = "android"
	GetAppParamsPlatformFireos      GetAppParamsPlatform = "fireos"
	GetAppParamsPlatformHarmonyos   GetAppParamsPlatform = "harmonyos"
	GetAppParamsPlatformIos         GetAppParamsPlatform = "ios"
	GetAppParamsPlatformPlaystation GetAppParamsPlatform = "playstation"
	GetAppParamsPlatformRoku        GetAppParamsPlatform = "roku"
	GetAppParamsPlatformTizen       GetAppParamsPlatform = "tizen"
	GetAppParamsPlatformWeb         GetAppParamsPlatform = "web"
	GetAppParamsPlatformWebos       GetAppParamsPlatform = "webos"
	GetAppParamsPlatformXbox        GetAppParamsPlatform = "xbox"
)

// Defines values for PostAppJSONBodyPlatform.
const (
	PostAppJSONBodyPlatformAndroid     PostAppJSONBodyPlatform = "android"
	PostAppJSONBodyPlatformFireos      PostAppJSONBodyPlatform = "fireos"
	PostAppJSONBodyPlatformHarmonyos   PostAppJSONBodyPlatform = "harmonyos"
	PostAppJSONBodyPlatformIos         PostAppJSONBodyPlatform = "ios"
	PostAppJSONBodyPlatformPlaystation PostAppJSONBodyPlatform = "playstation"
	PostAppJSONBodyPlatformRoku        PostAppJSONBodyPlatform = "roku"
	PostAppJSONBodyPlatformTizen       PostAppJSONBodyPlatform = "tizen"
	PostAppJSONBodyPlatformWeb         PostAppJSONBodyPlatform = "web"
	PostAppJSONBodyPlatformWebos       PostAppJSONBodyPlatform = "webos"
	PostAppJSONBodyPlatformXbox        PostAppJSONBodyPlatform = "xbox"
)

// Defines values for GetAppPlatformPackageParamsPlatform.
const (
	GetAppPlatformPackageParamsPlatformAndroid     GetAppPlatformPackageParamsPlatform = "android"
	GetAppPlatformPackageParamsPlatformFireos      GetAppPlatformPackageParamsPlatform = "fireos"
	GetAppPlatformPackageParamsPlatformHarmonyos   GetAppPlatformPackageParamsPlatform = "harmonyos"
	GetAppPlatformPackageParamsPlatformIos         GetAppPlatformPackageParamsPlatform = "ios"
	GetAppPlatformPackageParamsPlatformPlaystation GetAppPlatformPackageParamsPlatform = "playstation"
	GetAppPlatformPackageParamsPlatformRoku        GetAppPlatformPackageParamsPlatform = "roku"
	GetAppPlatformPackageParamsPlatformTizen       GetAppPlatformPackageParamsPlatform = "tizen"
	GetAppPlatformPackageParamsPlatformWeb         GetAppPlatformPackageParamsPlatform = "web"
	GetAppPlatformPackageParamsPlatformWebos       GetAppPlatformPackageParamsPlatform = "webos"
	GetAppPlatformPackageParamsPlatformXbox        GetAppPlatformPackageParamsPlatform = "xbox"
)

// Defines values for GetAppPlatformPackageAssessmentParamsPlatform.
const (
	GetAppPlatformPackageAssessmentParamsPlatformAndroid     GetAppPlatformPackageAssessmentParamsPlatform = "android"
	GetAppPlatformPackageAssessmentParamsPlatformFireos      GetAppPlatformPackageAssessmentParamsPlatform = "fireos"
	GetAppPlatformPackageAssessmentParamsPlatformHarmonyos   GetAppPlatformPackageAssessmentParamsPlatform = "harmonyos"
	GetAppPlatformPackageAssessmentParamsPlatformIos         GetAppPlatformPackageAssessmentParamsPlatform = "ios"
	GetAppPlatformPackageAssessmentParamsPlatformPlaystation GetAppPlatformPackageAssessmentParamsPlatform = "playstation"
	GetAppPlatformPackageAssessmentParamsPlatformRoku        GetAppPlatformPackageAssessmentParamsPlatform = "roku"
	GetAppPlatformPackageAssessmentParamsPlatformTizen       GetAppPlatformPackageAssessmentParamsPlatform = "tizen"
	GetAppPlatformPackageAssessmentParamsPlatformWeb         GetAppPlatformPackageAssessmentParamsPlatform = "web"
	GetAppPlatformPackageAssessmentParamsPlatformWebos       GetAppPlatformPackageAssessmentParamsPlatform = "webos"
	GetAppPlatformPackageAssessmentParamsPlatformXbox        GetAppPlatformPackageAssessmentParamsPlatform = "xbox"
)

// Defines values for PostAppPlatformPackageAssessmentParamsAnalysisType.
const (
	PostAppPlatformPackageAssessmentParamsAnalysisTypeFull   PostAppPlatformPackageAssessmentParamsAnalysisType = "full"
	PostAppPlatformPackageAssessmentParamsAnalysisTypeSbom   PostAppPlatformPackageAssessmentParamsAnalysisType = "sbom"
	PostAppPlatformPackageAssessmentParamsAnalysisTypeStatic PostAppPlatformPackageAssessmentParamsAnalysisType = "static"
)

// Defines values for PostAppPlatformPackageAssessmentParamsPlatform.
const (
	PostAppPlatformPackageAssessmentParamsPlatformAndroid PostAppPlatformPackageAssessmentParamsPlatform = "android"
	PostAppPlatformPackageAssessmentParamsPlatformIos     PostAppPlatformPackageAssessmentParamsPlatform = "ios"
)

// Defines values for GetAppPlatformPackageAssessmentTaskParamsPlatform.
const (
	GetAppPlatformPackageAssessmentTaskParamsPlatformAndroid GetAppPlatformPackageAssessmentTaskParamsPlatform = "android"
	GetAppPlatformPackageAssessmentTaskParamsPlatformIos     GetAppPlatformPackageAssessmentTaskParamsPlatform = "ios"
)

// Defines values for GetAppPlatformPackageAssessmentTaskRawParamsPlatform.
const (
	GetAppPlatformPackageAssessmentTaskRawParamsPlatformAndroid GetAppPlatformPackageAssessmentTaskRawParamsPlatform = "android"
	GetAppPlatformPackageAssessmentTaskRawParamsPlatformIos     GetAppPlatformPackageAssessmentTaskRawParamsPlatform = "ios"
)

// Defines values for PostAppPlatformPackageAssessmentTaskCancelParamsPlatform.
const (
	PostAppPlatformPackageAssessmentTaskCancelParamsPlatformAndroid PostAppPlatformPackageAssessmentTaskCancelParamsPlatform = "android"
	PostAppPlatformPackageAssessmentTaskCancelParamsPlatformIos     PostAppPlatformPackageAssessmentTaskCancelParamsPlatform = "ios"
)

// Defines values for GetAppPlatformPackageAssessmentTaskReportParamsPlatform.
const (
	GetAppPlatformPackageAssessmentTaskReportParamsPlatformAndroid GetAppPlatformPackageAssessmentTaskReportParamsPlatform = "android"
	GetAppPlatformPackageAssessmentTaskReportParamsPlatformIos     GetAppPlatformPackageAssessmentTaskReportParamsPlatform = "ios"
)

// Defines values for GetAppPlatformPackageAssessmentTaskResultsParamsPlatform.
const (
	GetAppPlatformPackageAssessmentTaskResultsParamsPlatformAndroid GetAppPlatformPackageAssessmentTaskResultsParamsPlatform = "android"
	GetAppPlatformPackageAssessmentTaskResultsParamsPlatformIos     GetAppPlatformPackageAssessmentTaskResultsParamsPlatform = "ios"
)

// Defines values for PostAppPlatformPackageBinaryParamsPlatform.
const (
	PostAppPlatformPackageBinaryParamsPlatformAndroid PostAppPlatformPackageBinaryParamsPlatform = "android"
	PostAppPlatformPackageBinaryParamsPlatformIos     PostAppPlatformPackageBinaryParamsPlatform = "ios"
)

// Defines values for GetAppPlatformPackageBuildParamsPlatform.
const (
	GetAppPlatformPackageBuildParamsPlatformAndroid     GetAppPlatformPackageBuildParamsPlatform = "android"
	GetAppPlatformPackageBuildParamsPlatformFireos      GetAppPlatformPackageBuildParamsPlatform = "fireos"
	GetAppPlatformPackageBuildParamsPlatformHarmonyos   GetAppPlatformPackageBuildParamsPlatform = "harmonyos"
	GetAppPlatformPackageBuildParamsPlatformIos         GetAppPlatformPackageBuildParamsPlatform = "ios"
	GetAppPlatformPackageBuildParamsPlatformPlaystation GetAppPlatformPackageBuildParamsPlatform = "playstation"
	GetAppPlatformPackageBuildParamsPlatformRoku        GetAppPlatformPackageBuildParamsPlatform = "roku"
	GetAppPlatformPackageBuildParamsPlatformTizen       GetAppPlatformPackageBuildParamsPlatform = "tizen"
	GetAppPlatformPackageBuildParamsPlatformWeb         GetAppPlatformPackageBuildParamsPlatform = "web"
	GetAppPlatformPackageBuildParamsPlatformWebos       GetAppPlatformPackageBuildParamsPlatform = "webos"
	GetAppPlatformPackageBuildParamsPlatformXbox        GetAppPlatformPackageBuildParamsPlatform = "xbox"
)

// Defines values for GetAppPlatformPackageConfigParamsPlatform.
const (
	GetAppPlatformPackageConfigParamsPlatformAndroid GetAppPlatformPackageConfigParamsPlatform = "android"
	GetAppPlatformPackageConfigParamsPlatformIos     GetAppPlatformPackageConfigParamsPlatform = "ios"
)

// Defines values for PostAppPlatformPackageConfigParamsPlatform.
const (
	PostAppPlatformPackageConfigParamsPlatformAndroid PostAppPlatformPackageConfigParamsPlatform = "android"
	PostAppPlatformPackageConfigParamsPlatformIos     PostAppPlatformPackageConfigParamsPlatform = "ios"
)

// Defines values for DeleteAppPlatformPackageRunnerParamsPlatform.
const (
	DeleteAppPlatformPackageRunnerParamsPlatformAndroid DeleteAppPlatformPackageRunnerParamsPlatform = "android"
	DeleteAppPlatformPackageRunnerParamsPlatformIos     DeleteAppPlatformPackageRunnerParamsPlatform = "ios"
)

// Defines values for PostAppPlatformPackageRunnerParamsPlatform.
const (
	PostAppPlatformPackageRunnerParamsPlatformAndroid PostAppPlatformPackageRunnerParamsPlatform = "android"
	PostAppPlatformPackageRunnerParamsPlatformIos     PostAppPlatformPackageRunnerParamsPlatform = "ios"
)

// Defines values for GetAssessmentTaskFindingsParamsReport.
const (
	Intel   GetAssessmentTaskFindingsParamsReport = "intel"
	LabAuto GetAssessmentTaskFindingsParamsReport = "lab-auto"
	Niap    GetAssessmentTaskFindingsParamsReport = "niap"
)

// Defines values for PostBuildParamsAnalysisType.
const (
	PostBuildParamsAnalysisTypeSbom   PostBuildParamsAnalysisType = "sbom"
	PostBuildParamsAnalysisTypeStatic PostBuildParamsAnalysisType = "static"
)

// Defines values for PostBuildPlatformPackageParamsPlatform.
const (
	PostBuildPlatformPackageParamsPlatformAndroid PostBuildPlatformPackageParamsPlatform = "android"
	PostBuildPlatformPackageParamsPlatformIos     PostBuildPlatformPackageParamsPlatform = "ios"
)

// ActionResult defines model for ActionResult.
type ActionResult struct {
	// Success The success of the operation.
	Success bool `json:"success"`
}

// AppBuild Builds refer to application binaries either uploaded by the user or downloaded from a store.
type AppBuild struct {
	// Account Deprecated. Use group instead.
	Account openapi_types.UUID `json:"account"`

	// Analyzed True if the last analysis of this application has completed.
	Analyzed *bool `json:"analyzed,omitempty"`

	// Created Creation date of the application record.
	Created time.Time `json:"created"`

	// Digest The SHA-256 digest of the analyzed binary. Note that some applications are repackaged prior to analysis, so this digest may differ from the digest of the uploaded file.
	Digest string `json:"digest"`

	// DownloadedAppstoreApplicationKey The App store / Play store key for applications downloaded from a store.
	DownloadedAppstoreApplicationKey *string `json:"downloaded_appstore_application_key,omitempty"`

	// Group The UUID identifier of the group this application belongs to.
	Group openapi_types.UUID `json:"group"`

	// Icon The icon of the application in base64 format.
	Icon *string `json:"icon,omitempty"`

	// Package The package or bundle ID.
	Package string `json:"package"`

	// Platform The operating system of the application (android or ios).
	Platform *string `json:"platform,omitempty"`

	// Ref The UUID identifier of the application binary.
	Ref openapi_types.UUID `json:"ref"`

	// Title The application title.
	Title *string `json:"title,omitempty"`

	// Uploaded The date-time the binary was uploaded.
	Uploaded *string `json:"uploaded,omitempty"`

	// Uploader The UUID identifier of the user who uploaded the application.
	Uploader *string `json:"uploader,omitempty"`

	// Version The application version string.
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AppBuildList defines model for AppBuildList.
type AppBuildList = []AppBuild

// LabApp defines model for LabApp.
type LabApp struct {
	// Account The UUID ref of the group the application is in.
	Account openapi_types.UUID `json:"account"`

	// AppstoreApplicationKey For an uploaded application, the iOS application store ID or Android package name.
	AppstoreApplicationKey *interface{} `json:"appstore_application_key,omitempty"`

	// ArchivedAt The date-time the application was archived.
	ArchivedAt *time.Time `json:"archived_at,omitempty"`

	// Binary The binary digest for the current build.
	Binary *string `json:"binary,omitempty"`
	Config *struct {
		Dynamic      *LabApp_Config_Dynamic `json:"dynamic,omitempty"`
		Integrations *struct {
			PENTEST *struct {
				Azure *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						ReferenceName string `json:"referenceName"`
						Type          string `json:"type"`
						Value         string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					OrganizationName     string                  `json:"organizationName"`
					ProjectId            string                  `json:"projectId"`
					Tags                 *[]string               `json:"tags,omitempty"`
					WorkItemType         string                  `json:"workItemType"`
				} `json:"azure,omitempty"`
				Github *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					Labels                    *[]string `json:"labels,omitempty"`
					Repository                string    `json:"repository"`
				} `json:"github,omitempty"`
				Gitlab *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
					GroupId                   string    `json:"groupId"`
					Labels                    *[]string `json:"labels,omitempty"`
					ProjectId                 string    `json:"projectId"`
				} `json:"gitlab,omitempty"`
				Jira *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					BaseUrl                   *string `json:"baseUrl,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						Name  string `json:"name"`
						Type  string `json:"type"`
						Value string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					IssueType            *string                 `json:"issueType,omitempty"`
					Labels               *[]string               `json:"labels,omitempty"`
					Project              string                  `json:"project"`
				} `json:"jira,omitempty"`
				Servicenow *struct {
					AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
					AutomationRules      struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CategorySysId             *string `json:"categorySysId,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
					ImpactLevel               *string `json:"impactLevel,omitempty"`
					UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
				} `json:"servicenow,omitempty"`
			} `json:"PEN_TEST,omitempty"`
			PLATFORM *struct {
				Azure *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						ReferenceName string `json:"referenceName"`
						Type          string `json:"type"`
						Value         string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					OrganizationName     string                  `json:"organizationName"`
					ProjectId            string                  `json:"projectId"`
					Tags                 *[]string               `json:"tags,omitempty"`
					WorkItemType         string                  `json:"workItemType"`
				} `json:"azure,omitempty"`
				Github *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					Labels                    *[]string `json:"labels,omitempty"`
					Repository                string    `json:"repository"`
				} `json:"github,omitempty"`
				Gitlab *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
					GroupId                   string    `json:"groupId"`
					Labels                    *[]string `json:"labels,omitempty"`
					ProjectId                 string    `json:"projectId"`
				} `json:"gitlab,omitempty"`
				Jira *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					BaseUrl                   *string `json:"baseUrl,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						Name  string `json:"name"`
						Type  string `json:"type"`
						Value string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					IssueType            *string                 `json:"issueType,omitempty"`
					Labels               *[]string               `json:"labels,omitempty"`
					Project              string                  `json:"project"`
				} `json:"jira,omitempty"`
				Servicenow *struct {
					AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
					AutomationRules      struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CategorySysId             *string `json:"categorySysId,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
					ImpactLevel               *string `json:"impactLevel,omitempty"`
					UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
				} `json:"servicenow,omitempty"`
			} `json:"PLATFORM,omitempty"`
		} `json:"integrations,omitempty"`
		Static *LabApp_Config_Static `json:"static,omitempty"`
	} `json:"config,omitempty"`

	// ConfigLevel The analysis config level of the application.
	ConfigLevel *LabAppConfigLevel `json:"config_level,omitempty"`

	// Created The date-time the application was created.
	Created *time.Time `json:"created,omitempty"`

	// FindingsOverrides The object associating user-made overrides to findings by their key.
	FindingsOverrides *interface{} `json:"findings_overrides,omitempty"`

	// Forbidden Forbidden application records refer to iOS/Android app store downloads that cannot be scanned for various reasons at this time.
	Forbidden *struct {
		// Reason Application store forbidden reason
		Reason string `json:"reason"`

		// ReasonDescription Describes why an application is currently forbidden from testing
		ReasonDescription string `json:"reasonDescription"`
	} `json:"forbidden,omitempty"`

	// Group The UUID ref of the group the application is in.
	Group        openapi_types.UUID `json:"group"`
	Integrations *struct {
		PENTEST *struct {
			Azure *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					ReferenceName string `json:"referenceName"`
					Type          string `json:"type"`
					Value         string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				OrganizationName     string                  `json:"organizationName"`
				ProjectId            string                  `json:"projectId"`
				Tags                 *[]string               `json:"tags,omitempty"`
				WorkItemType         string                  `json:"workItemType"`
			} `json:"azure,omitempty"`
			Github *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				Labels                    *[]string `json:"labels,omitempty"`
				Repository                string    `json:"repository"`
			} `json:"github,omitempty"`
			Gitlab *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
				GroupId                   string    `json:"groupId"`
				Labels                    *[]string `json:"labels,omitempty"`
				ProjectId                 string    `json:"projectId"`
			} `json:"gitlab,omitempty"`
			Jira *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				BaseUrl                   *string `json:"baseUrl,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					Name  string `json:"name"`
					Type  string `json:"type"`
					Value string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				IssueType            *string                 `json:"issueType,omitempty"`
				Labels               *[]string               `json:"labels,omitempty"`
				Project              string                  `json:"project"`
			} `json:"jira,omitempty"`
			Servicenow *struct {
				AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
				AutomationRules      struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CategorySysId             *string `json:"categorySysId,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
				ImpactLevel               *string `json:"impactLevel,omitempty"`
				UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
			} `json:"servicenow,omitempty"`
		} `json:"PEN_TEST,omitempty"`
		PLATFORM *struct {
			Azure *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					ReferenceName string `json:"referenceName"`
					Type          string `json:"type"`
					Value         string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				OrganizationName     string                  `json:"organizationName"`
				ProjectId            string                  `json:"projectId"`
				Tags                 *[]string               `json:"tags,omitempty"`
				WorkItemType         string                  `json:"workItemType"`
			} `json:"azure,omitempty"`
			Github *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				Labels                    *[]string `json:"labels,omitempty"`
				Repository                string    `json:"repository"`
			} `json:"github,omitempty"`
			Gitlab *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
				GroupId                   string    `json:"groupId"`
				Labels                    *[]string `json:"labels,omitempty"`
				ProjectId                 string    `json:"projectId"`
			} `json:"gitlab,omitempty"`
			Jira *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				BaseUrl                   *string `json:"baseUrl,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					Name  string `json:"name"`
					Type  string `json:"type"`
					Value string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				IssueType            *string                 `json:"issueType,omitempty"`
				Labels               *[]string               `json:"labels,omitempty"`
				Project              string                  `json:"project"`
			} `json:"jira,omitempty"`
			Servicenow *struct {
				AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
				AutomationRules      struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CategorySysId             *string `json:"categorySysId,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
				ImpactLevel               *string `json:"impactLevel,omitempty"`
				UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
			} `json:"servicenow,omitempty"`
		} `json:"PLATFORM,omitempty"`
	} `json:"integrations,omitempty"`

	// Package The package ID of the application.
	Package string `json:"package"`

	// Platform The operating system of the application.
	Platform LabAppPlatform `json:"platform"`

	// Ref The UUID ref of the application.
	Ref openapi_types.UUID `json:"ref"`

	// TestRunnerBinary The binary digest of the currently uploaded test runner binary.
	TestRunnerBinary *string `json:"test_runner_binary,omitempty"`

	// Title The title of the application.
	Title                *string                `json:"title,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// LabAppConfigDynamic0 defines model for .
type LabAppConfigDynamic0 = bool

// LabAppConfigDynamic1 defines model for .
type LabAppConfigDynamic1 = map[string]interface{}

// LabAppConfigDynamic2 The dynamic configuration for the application.
type LabAppConfigDynamic2 map[string]interface{}

// LabApp_Config_Dynamic defines model for LabApp.Config.Dynamic.
type LabApp_Config_Dynamic struct {
	union json.RawMessage
}

// LabAppConfigStatic0 defines model for .
type LabAppConfigStatic0 = bool

// LabAppConfigStatic1 defines model for .
type LabAppConfigStatic1 = map[string]interface{}

// LabAppConfigStatic2 The static configuration for the application.
type LabAppConfigStatic2 map[string]interface{}

// LabApp_Config_Static defines model for LabApp.Config.Static.
type LabApp_Config_Static struct {
	union json.RawMessage
}

// LabAppConfigLevel The analysis config level of the application.
type LabAppConfigLevel string

// LabAppPlatform The operating system of the application.
type LabAppPlatform string

// LabRouteError defines model for labRouteError.
type LabRouteError struct {
	Description          *string                `json:"description,omitempty"`
	Message              *string                `json:"message,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	Status               *string                `json:"status,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// StandardError defines model for standardError.
type StandardError struct {
	// Code Error code
	Code *string `json:"code,omitempty"`

	// Error Error flag
	Error  *bool     `json:"error,omitempty"`
	Errors *[]string `json:"errors,omitempty"`

	// Message Error message
	Message string `json:"message"`

	// Name Error name
	Name *string `json:"name,omitempty"`

	// Stack Error stacktrace
	Stack *string `json:"stack,omitempty"`

	// Type Error type
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetAccountUserParams defines parameters for GetAccountUser.
type GetAccountUserParams struct {
	// Domain Optionally filter users by email domain.
	Domain *struct {
		union json.RawMessage
	} `form:"domain,omitempty" json:"domain,omitempty"`

	// ExcludeRole Optionally exclude users with specific roles.
	ExcludeRole *struct {
		union json.RawMessage
	} `form:"exclude_role,omitempty" json:"exclude_role,omitempty"`
}

// GetAccountUserParamsDomain0 defines parameters for GetAccountUser.
type GetAccountUserParamsDomain0 = string

// GetAccountUserParamsDomain1 defines parameters for GetAccountUser.
type GetAccountUserParamsDomain1 = []string

// GetAccountUserParamsExcludeRole0 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole0 struct {
	union json.RawMessage
}

// GetAccountUserParamsExcludeRole00 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole00 string

// GetAccountUserParamsExcludeRole01 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole01 string

// GetAccountUserParamsExcludeRole02 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole02 string

// GetAccountUserParamsExcludeRole03 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole03 string

// GetAccountUserParamsExcludeRole04 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole04 string

// GetAccountUserParamsExcludeRole05 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole05 string

// GetAccountUserParamsExcludeRole06 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole06 string

// GetAccountUserParamsExcludeRole07 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole07 string

// GetAccountUserParamsExcludeRole08 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole08 string

// GetAccountUserParamsExcludeRole09 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole09 string

// GetAccountUserParamsExcludeRole010 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole010 string

// GetAccountUserParamsExcludeRole011 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole011 string

// GetAccountUserParamsExcludeRole012 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole012 string

// GetAccountUserParamsExcludeRole013 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole013 string

// GetAccountUserParamsExcludeRole1 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole1 = []GetAccountUserParams_ExcludeRole_1_Item

// GetAccountUserParamsExcludeRole10 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole10 string

// GetAccountUserParamsExcludeRole11 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole11 string

// GetAccountUserParamsExcludeRole12 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole12 string

// GetAccountUserParamsExcludeRole13 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole13 string

// GetAccountUserParamsExcludeRole14 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole14 string

// GetAccountUserParamsExcludeRole15 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole15 string

// GetAccountUserParamsExcludeRole16 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole16 string

// GetAccountUserParamsExcludeRole17 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole17 string

// GetAccountUserParamsExcludeRole18 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole18 string

// GetAccountUserParamsExcludeRole19 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole19 string

// GetAccountUserParamsExcludeRole110 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole110 string

// GetAccountUserParamsExcludeRole111 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole111 string

// GetAccountUserParamsExcludeRole112 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole112 string

// GetAccountUserParamsExcludeRole113 defines parameters for GetAccountUser.
type GetAccountUserParamsExcludeRole113 string

// GetAccountUserParams_ExcludeRole_1_Item defines parameters for GetAccountUser.
type GetAccountUserParams_ExcludeRole_1_Item struct {
	union json.RawMessage
}

// GetAppParams defines parameters for GetApp.
type GetAppParams struct {
	// Platform The platform of the applications to list.
	Platform *GetAppParamsPlatform `form:"platform,omitempty" json:"platform,omitempty"`

	// Package The package ID of the applications to list.
	Package *string `form:"package,omitempty" json:"package,omitempty"`

	// Group The UUID ref of the group to list apps for.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// Ref The UUID ref of the application to list.
	Ref *openapi_types.UUID `form:"ref,omitempty" json:"ref,omitempty"`

	// Limit Limit the number of results listed.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAppParamsPlatform defines parameters for GetApp.
type GetAppParamsPlatform string

// PostAppJSONBody defines parameters for PostApp.
type PostAppJSONBody struct {
	// AppstoreApplicationKey The appstore application key of the application to create.
	AppstoreApplicationKey *string `json:"appstore_application_key,omitempty"`

	// Binary The binary digest of the latest uploaded binary for the application to create.
	Binary *string `json:"binary,omitempty"`
	Config *struct {
		// Dynamic The dynamic configuration for the application.
		Dynamic *map[string]interface{} `json:"dynamic,omitempty"`

		// Static The static configuration for the application.
		Static *map[string]interface{} `json:"static,omitempty"`
	} `json:"config,omitempty"`

	// Group The UUID group ref of the application to create (Optional if the user is only in one group).
	Group        *openapi_types.UUID `json:"group,omitempty"`
	Integrations *struct {
		PENTEST *struct {
			Azure *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					ReferenceName string `json:"referenceName"`
					Type          string `json:"type"`
					Value         string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				OrganizationName     string                  `json:"organizationName"`
				ProjectId            string                  `json:"projectId"`
				Tags                 *[]string               `json:"tags,omitempty"`
				WorkItemType         string                  `json:"workItemType"`
			} `json:"azure,omitempty"`
			Github *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				Labels                    *[]string `json:"labels,omitempty"`
				Repository                string    `json:"repository"`
			} `json:"github,omitempty"`
			Gitlab *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
				GroupId                   string    `json:"groupId"`
				Labels                    *[]string `json:"labels,omitempty"`
				ProjectId                 string    `json:"projectId"`
			} `json:"gitlab,omitempty"`
			Jira *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				BaseUrl                   *string `json:"baseUrl,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					Name  string `json:"name"`
					Type  string `json:"type"`
					Value string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				IssueType            *string                 `json:"issueType,omitempty"`
				Labels               *[]string               `json:"labels,omitempty"`
				Project              string                  `json:"project"`
			} `json:"jira,omitempty"`
			Servicenow *struct {
				AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
				AutomationRules      struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CategorySysId             *string `json:"categorySysId,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
				ImpactLevel               *string `json:"impactLevel,omitempty"`
				UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
			} `json:"servicenow,omitempty"`
		} `json:"PEN_TEST,omitempty"`
		PLATFORM *struct {
			Azure *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					ReferenceName string `json:"referenceName"`
					Type          string `json:"type"`
					Value         string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				OrganizationName     string                  `json:"organizationName"`
				ProjectId            string                  `json:"projectId"`
				Tags                 *[]string               `json:"tags,omitempty"`
				WorkItemType         string                  `json:"workItemType"`
			} `json:"azure,omitempty"`
			Github *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				Labels                    *[]string `json:"labels,omitempty"`
				Repository                string    `json:"repository"`
			} `json:"github,omitempty"`
			Gitlab *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
				GroupId                   string    `json:"groupId"`
				Labels                    *[]string `json:"labels,omitempty"`
				ProjectId                 string    `json:"projectId"`
			} `json:"gitlab,omitempty"`
			Jira *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				BaseUrl                   *string `json:"baseUrl,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					Name  string `json:"name"`
					Type  string `json:"type"`
					Value string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				IssueType            *string                 `json:"issueType,omitempty"`
				Labels               *[]string               `json:"labels,omitempty"`
				Project              string                  `json:"project"`
			} `json:"jira,omitempty"`
			Servicenow *struct {
				AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
				AutomationRules      struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CategorySysId             *string `json:"categorySysId,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
				ImpactLevel               *string `json:"impactLevel,omitempty"`
				UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
			} `json:"servicenow,omitempty"`
		} `json:"PLATFORM,omitempty"`
	} `json:"integrations,omitempty"`

	// Package The package ID of the application to create.
	Package string `json:"package"`

	// Platform The platform of the application to create.
	Platform PostAppJSONBodyPlatform `json:"platform"`

	// Title The title of the application to create.
	Title *string `json:"title,omitempty"`
}

// PostAppParams defines parameters for PostApp.
type PostAppParams struct {
	// Group The UUID group ref of the application to create (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// PostAppJSONBodyPlatform defines parameters for PostApp.
type PostAppJSONBodyPlatform string

// GetAppPlatformPackageParams defines parameters for GetAppPlatformPackage.
type GetAppPlatformPackageParams struct {
	// Group The UUID group ref of the application to get (Optional if the application is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageParamsPlatform defines parameters for GetAppPlatformPackage.
type GetAppPlatformPackageParamsPlatform string

// GetAppPlatformPackageAssessmentParams defines parameters for GetAppPlatformPackageAssessment.
type GetAppPlatformPackageAssessmentParams struct {
	// Group The group ID of the target application. Required if the application exists in more than one group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageAssessmentParamsPlatform defines parameters for GetAppPlatformPackageAssessment.
type GetAppPlatformPackageAssessmentParamsPlatform string

// PostAppPlatformPackageAssessmentParams defines parameters for PostAppPlatformPackageAssessment.
type PostAppPlatformPackageAssessmentParams struct {
	// Group The UUID group ref of the application to trigger an assessment for (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// AppstoreDownload Set to "*" to trigger an app store assessment for the latest app store version available to NowSecure. Otherwise, an assessment is triggered for the latest uploaded binary.
	AppstoreDownload *string `form:"appstore_download,omitempty" json:"appstore_download,omitempty"`

	// Failfast Set to "true" to trigger a "failfast" assessment. Failfast assessments run pass 2 first so automation scripting failures can be identified quickly.
	Failfast *bool `form:"failfast,omitempty" json:"failfast,omitempty"`

	// AnalysisType The type of assessment to trigger. If specified, must be one of "full", "static" or "sbom".
	AnalysisType *PostAppPlatformPackageAssessmentParamsAnalysisType `form:"analysisType,omitempty" json:"analysisType,omitempty"`

	// HideSensitiveDataValues Specifying a value of `true` will hide sensitive values from the app configuration data returned with the assessment.
	HideSensitiveDataValues *bool `form:"hideSensitiveDataValues,omitempty" json:"hideSensitiveDataValues,omitempty"`
}

// PostAppPlatformPackageAssessmentParamsAnalysisType defines parameters for PostAppPlatformPackageAssessment.
type PostAppPlatformPackageAssessmentParamsAnalysisType string

// PostAppPlatformPackageAssessmentParamsPlatform defines parameters for PostAppPlatformPackageAssessment.
type PostAppPlatformPackageAssessmentParamsPlatform string

// GetAppPlatformPackageAssessmentTaskParams defines parameters for GetAppPlatformPackageAssessmentTask.
type GetAppPlatformPackageAssessmentTaskParams struct {
	// Group The group ID of the application to get an assessment for. Required if the application exists in more than one group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageAssessmentTaskParamsPlatform defines parameters for GetAppPlatformPackageAssessmentTask.
type GetAppPlatformPackageAssessmentTaskParamsPlatform string

// GetAppPlatformPackageAssessmentTaskRawParams defines parameters for GetAppPlatformPackageAssessmentTaskRaw.
type GetAppPlatformPackageAssessmentTaskRawParams struct {
	// Group The group ID of the target assessment. Required if the application exists in more than one group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageAssessmentTaskRawParamsPlatform defines parameters for GetAppPlatformPackageAssessmentTaskRaw.
type GetAppPlatformPackageAssessmentTaskRawParamsPlatform string

// PostAppPlatformPackageAssessmentTaskCancelParamsPlatform defines parameters for PostAppPlatformPackageAssessmentTaskCancel.
type PostAppPlatformPackageAssessmentTaskCancelParamsPlatform string

// GetAppPlatformPackageAssessmentTaskReportParams defines parameters for GetAppPlatformPackageAssessmentTaskReport.
type GetAppPlatformPackageAssessmentTaskReportParams struct {
	// Group The group ID of the target assessment. Required if the application exists in more than one group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageAssessmentTaskReportParamsPlatform defines parameters for GetAppPlatformPackageAssessmentTaskReport.
type GetAppPlatformPackageAssessmentTaskReportParamsPlatform string

// GetAppPlatformPackageAssessmentTaskResultsParams defines parameters for GetAppPlatformPackageAssessmentTaskResults.
type GetAppPlatformPackageAssessmentTaskResultsParams struct {
	// Group The group ID of the target assessment. Required if the application exists in more than one group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageAssessmentTaskResultsParamsPlatform defines parameters for GetAppPlatformPackageAssessmentTaskResults.
type GetAppPlatformPackageAssessmentTaskResultsParamsPlatform string

// PostAppPlatformPackageBinaryParams defines parameters for PostAppPlatformPackageBinary.
type PostAppPlatformPackageBinaryParams struct {
	// Group The UUID ref of the group containing the application (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// PostAppPlatformPackageBinaryParamsPlatform defines parameters for PostAppPlatformPackageBinary.
type PostAppPlatformPackageBinaryParamsPlatform string

// GetAppPlatformPackageBuildParams defines parameters for GetAppPlatformPackageBuild.
type GetAppPlatformPackageBuildParams struct {
	// Group The group ID of the target application. If not specified all groups will be searched.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageBuildParamsPlatform defines parameters for GetAppPlatformPackageBuild.
type GetAppPlatformPackageBuildParamsPlatform string

// GetAppPlatformPackageConfigParams defines parameters for GetAppPlatformPackageConfig.
type GetAppPlatformPackageConfigParams struct {
	// Group The UUID group ref of the application to get the config for (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// GetAppPlatformPackageConfigParamsPlatform defines parameters for GetAppPlatformPackageConfig.
type GetAppPlatformPackageConfigParamsPlatform string

// PostAppPlatformPackageConfigJSONBody defines parameters for PostAppPlatformPackageConfig.
type PostAppPlatformPackageConfigJSONBody struct {
	// Dynamic The dynamic configuration for the application.
	Dynamic      *map[string]interface{} `json:"dynamic,omitempty"`
	Integrations *struct {
		PENTEST *struct {
			Azure *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					ReferenceName string `json:"referenceName"`
					Type          string `json:"type"`
					Value         string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				OrganizationName     string                  `json:"organizationName"`
				ProjectId            string                  `json:"projectId"`
				Tags                 *[]string               `json:"tags,omitempty"`
				WorkItemType         string                  `json:"workItemType"`
			} `json:"azure,omitempty"`
			Github *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				Labels                    *[]string `json:"labels,omitempty"`
				Repository                string    `json:"repository"`
			} `json:"github,omitempty"`
			Gitlab *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
				GroupId                   string    `json:"groupId"`
				Labels                    *[]string `json:"labels,omitempty"`
				ProjectId                 string    `json:"projectId"`
			} `json:"gitlab,omitempty"`
			Jira *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				BaseUrl                   *string `json:"baseUrl,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					Name  string `json:"name"`
					Type  string `json:"type"`
					Value string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				IssueType            *string                 `json:"issueType,omitempty"`
				Labels               *[]string               `json:"labels,omitempty"`
				Project              string                  `json:"project"`
			} `json:"jira,omitempty"`
			Servicenow *struct {
				AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
				AutomationRules      struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CategorySysId             *string `json:"categorySysId,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
				ImpactLevel               *string `json:"impactLevel,omitempty"`
				UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
			} `json:"servicenow,omitempty"`
		} `json:"PEN_TEST,omitempty"`
		PLATFORM *struct {
			Azure *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					ReferenceName string `json:"referenceName"`
					Type          string `json:"type"`
					Value         string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				OrganizationName     string                  `json:"organizationName"`
				ProjectId            string                  `json:"projectId"`
				Tags                 *[]string               `json:"tags,omitempty"`
				WorkItemType         string                  `json:"workItemType"`
			} `json:"azure,omitempty"`
			Github *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				Labels                    *[]string `json:"labels,omitempty"`
				Repository                string    `json:"repository"`
			} `json:"github,omitempty"`
			Gitlab *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
				GroupId                   string    `json:"groupId"`
				Labels                    *[]string `json:"labels,omitempty"`
				ProjectId                 string    `json:"projectId"`
			} `json:"gitlab,omitempty"`
			Jira *struct {
				AutomationRules struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				BaseUrl                   *string `json:"baseUrl,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				CustomFields              *[]struct {
					Name  string `json:"name"`
					Type  string `json:"type"`
					Value string `json:"value"`
				} `json:"customFields,omitempty"`
				ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
				IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
				IssueType            *string                 `json:"issueType,omitempty"`
				Labels               *[]string               `json:"labels,omitempty"`
				Project              string                  `json:"project"`
			} `json:"jira,omitempty"`
			Servicenow *struct {
				AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
				AutomationRules      struct {
					PolicyCategories *struct {
						Category1 bool `json:"category1"`
						Category2 bool `json:"category2"`
						Category3 bool `json:"category3"`
					} `json:"policyCategories,omitempty"`
					Severities *struct {
						Critical bool `json:"critical"`
						High     bool `json:"high"`
						Info     bool `json:"info"`
						Low      bool `json:"low"`
						Medium   bool `json:"medium"`
						Warn     bool `json:"warn"`
					} `json:"severities,omitempty"`
				} `json:"automationRules"`
				CategorySysId             *string `json:"categorySysId,omitempty"`
				CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
				ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
				ImpactLevel               *string `json:"impactLevel,omitempty"`
				UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
			} `json:"servicenow,omitempty"`
		} `json:"PLATFORM,omitempty"`
	} `json:"integrations,omitempty"`

	// Static The static configuration for the application.
	Static *map[string]interface{} `json:"static,omitempty"`
}

// PostAppPlatformPackageConfigParams defines parameters for PostAppPlatformPackageConfig.
type PostAppPlatformPackageConfigParams struct {
	// Group The UUID group ref of the application to update the config for. Optional if the user is only in one group.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// PostAppPlatformPackageConfigParamsPlatform defines parameters for PostAppPlatformPackageConfig.
type PostAppPlatformPackageConfigParamsPlatform string

// DeleteAppPlatformPackageRunnerParams defines parameters for DeleteAppPlatformPackageRunner.
type DeleteAppPlatformPackageRunnerParams struct {
	// Group The UUID group ref of the application to delete the runner for (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// DeleteAppPlatformPackageRunnerParamsPlatform defines parameters for DeleteAppPlatformPackageRunner.
type DeleteAppPlatformPackageRunnerParamsPlatform string

// PostAppPlatformPackageRunnerJSONBody defines parameters for PostAppPlatformPackageRunner.
type PostAppPlatformPackageRunnerJSONBody = map[string]interface{}

// PostAppPlatformPackageRunnerParams defines parameters for PostAppPlatformPackageRunner.
type PostAppPlatformPackageRunnerParams struct {
	// Group The UUID group ref of the application to upload the runner for (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// PostAppPlatformPackageRunnerParamsPlatform defines parameters for PostAppPlatformPackageRunner.
type PostAppPlatformPackageRunnerParamsPlatform string

// GetAssessmentTaskFindingsParams defines parameters for GetAssessmentTaskFindings.
type GetAssessmentTaskFindingsParams struct {
	// Group The group of the assessment to get findings for.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// UsingLegacy Set to true to use the legacy implementation of this endpoint (not recommended).
	UsingLegacy *bool `form:"using_legacy,omitempty" json:"using_legacy,omitempty"`

	// Report In combination with using_legacy=true, the type of report to generate.
	Report *GetAssessmentTaskFindingsParamsReport `form:"report,omitempty" json:"report,omitempty"`
}

// GetAssessmentTaskFindingsParamsReport defines parameters for GetAssessmentTaskFindings.
type GetAssessmentTaskFindingsParamsReport string

// GetAssessmentTaskSummaryParams defines parameters for GetAssessmentTaskSummary.
type GetAssessmentTaskSummaryParams struct {
	// Group The group of the assessment to get a summary for.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// PostBinaryJSONBody defines parameters for PostBinary.
type PostBinaryJSONBody = map[string]interface{}

// PostBinaryParams defines parameters for PostBinary.
type PostBinaryParams struct {
	// Group The UUID group ref of the group in which to upload the binary.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// GetBinaryDigestAnalysisParams defines parameters for GetBinaryDigestAnalysis.
type GetBinaryDigestAnalysisParams struct {
	// Group The UUID group ref of the binary to trigger preflight analysis for (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// IncludeStatusEvents Whether non-terminal status event updates are in the response stream.
	IncludeStatusEvents bool `form:"includeStatusEvents" json:"includeStatusEvents"`
}

// GetBuildParams defines parameters for GetBuild.
type GetBuildParams struct {
	// Group Only show applications in this group.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`
}

// PostBuildJSONBody defines parameters for PostBuild.
type PostBuildJSONBody = map[string]interface{}

// PostBuildParams defines parameters for PostBuild.
type PostBuildParams struct {
	// AnalysisType The type of analysis to perform.
	AnalysisType *PostBuildParamsAnalysisType `form:"analysisType,omitempty" json:"analysisType,omitempty"`

	// Version Specifying a value will explicitly set version key on the build, overriding the value ultimately extracted from build metadata.
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// Group The UUID ref of the group to use for the assessment (Optional if the user is only in one group).
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// Assessment Specifying a value of `false` will opt out of triggering a subsequent assessment. In this case the response is the digest information for the upload.
	Assessment *bool `form:"assessment,omitempty" json:"assessment,omitempty"`

	// HideSensitiveDataValues Specifying a value of `true` will hide sensitive values from the app configuration data returned with the assessment.
	HideSensitiveDataValues *bool `form:"hideSensitiveDataValues,omitempty" json:"hideSensitiveDataValues,omitempty"`
}

// PostBuildParamsAnalysisType defines parameters for PostBuild.
type PostBuildParamsAnalysisType string

// PostBuildPlatformPackageJSONBody defines parameters for PostBuildPlatformPackage.
type PostBuildPlatformPackageJSONBody = map[string]interface{}

// PostBuildPlatformPackageParams defines parameters for PostBuildPlatformPackage.
type PostBuildPlatformPackageParams struct {
	// Group The application group containing the application.
	Group openapi_types.UUID `form:"group" json:"group"`
}

// PostBuildPlatformPackageParamsPlatform defines parameters for PostBuildPlatformPackage.
type PostBuildPlatformPackageParamsPlatform string

// PostUserTokenJSONBody defines parameters for PostUserToken.
type PostUserTokenJSONBody struct {
	// ExpirationDays Expiration days
	ExpirationDays *float32 `json:"expirationDays,omitempty"`

	// Name Name
	Name string `json:"name"`
}

// PostUserTokenRefreshJSONBody defines parameters for PostUserTokenRefresh.
type PostUserTokenRefreshJSONBody struct {
	// ExpirationDays Expiration days
	ExpirationDays float32 `json:"expirationDays"`

	// Jti jti/ref
	Jti *openapi_types.UUID `json:"jti,omitempty"`

	// Name Name
	Name string `json:"name"`
}

// PostAppJSONRequestBody defines body for PostApp for application/json ContentType.
type PostAppJSONRequestBody PostAppJSONBody

// PostAppPlatformPackageConfigJSONRequestBody defines body for PostAppPlatformPackageConfig for application/json ContentType.
type PostAppPlatformPackageConfigJSONRequestBody PostAppPlatformPackageConfigJSONBody

// PostAppPlatformPackageRunnerJSONRequestBody defines body for PostAppPlatformPackageRunner for application/json ContentType.
type PostAppPlatformPackageRunnerJSONRequestBody = PostAppPlatformPackageRunnerJSONBody

// PostBinaryJSONRequestBody defines body for PostBinary for application/json ContentType.
type PostBinaryJSONRequestBody = PostBinaryJSONBody

// PostBuildJSONRequestBody defines body for PostBuild for application/json ContentType.
type PostBuildJSONRequestBody = PostBuildJSONBody

// PostBuildPlatformPackageJSONRequestBody defines body for PostBuildPlatformPackage for application/json ContentType.
type PostBuildPlatformPackageJSONRequestBody = PostBuildPlatformPackageJSONBody

// PostUserTokenJSONRequestBody defines body for PostUserToken for application/json ContentType.
type PostUserTokenJSONRequestBody PostUserTokenJSONBody

// PostUserTokenRefreshJSONRequestBody defines body for PostUserTokenRefresh for application/json ContentType.
type PostUserTokenRefreshJSONRequestBody PostUserTokenRefreshJSONBody

// Getter for additional properties for AppBuild. Returns the specified
// element and whether it was found
func (a AppBuild) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AppBuild
func (a *AppBuild) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AppBuild to handle AdditionalProperties
func (a *AppBuild) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["account"]; found {
		err = json.Unmarshal(raw, &a.Account)
		if err != nil {
			return fmt.Errorf("error reading 'account': %w", err)
		}
		delete(object, "account")
	}

	if raw, found := object["analyzed"]; found {
		err = json.Unmarshal(raw, &a.Analyzed)
		if err != nil {
			return fmt.Errorf("error reading 'analyzed': %w", err)
		}
		delete(object, "analyzed")
	}

	if raw, found := object["created"]; found {
		err = json.Unmarshal(raw, &a.Created)
		if err != nil {
			return fmt.Errorf("error reading 'created': %w", err)
		}
		delete(object, "created")
	}

	if raw, found := object["digest"]; found {
		err = json.Unmarshal(raw, &a.Digest)
		if err != nil {
			return fmt.Errorf("error reading 'digest': %w", err)
		}
		delete(object, "digest")
	}

	if raw, found := object["downloaded_appstore_application_key"]; found {
		err = json.Unmarshal(raw, &a.DownloadedAppstoreApplicationKey)
		if err != nil {
			return fmt.Errorf("error reading 'downloaded_appstore_application_key': %w", err)
		}
		delete(object, "downloaded_appstore_application_key")
	}

	if raw, found := object["group"]; found {
		err = json.Unmarshal(raw, &a.Group)
		if err != nil {
			return fmt.Errorf("error reading 'group': %w", err)
		}
		delete(object, "group")
	}

	if raw, found := object["icon"]; found {
		err = json.Unmarshal(raw, &a.Icon)
		if err != nil {
			return fmt.Errorf("error reading 'icon': %w", err)
		}
		delete(object, "icon")
	}

	if raw, found := object["package"]; found {
		err = json.Unmarshal(raw, &a.Package)
		if err != nil {
			return fmt.Errorf("error reading 'package': %w", err)
		}
		delete(object, "package")
	}

	if raw, found := object["platform"]; found {
		err = json.Unmarshal(raw, &a.Platform)
		if err != nil {
			return fmt.Errorf("error reading 'platform': %w", err)
		}
		delete(object, "platform")
	}

	if raw, found := object["ref"]; found {
		err = json.Unmarshal(raw, &a.Ref)
		if err != nil {
			return fmt.Errorf("error reading 'ref': %w", err)
		}
		delete(object, "ref")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["uploaded"]; found {
		err = json.Unmarshal(raw, &a.Uploaded)
		if err != nil {
			return fmt.Errorf("error reading 'uploaded': %w", err)
		}
		delete(object, "uploaded")
	}

	if raw, found := object["uploader"]; found {
		err = json.Unmarshal(raw, &a.Uploader)
		if err != nil {
			return fmt.Errorf("error reading 'uploader': %w", err)
		}
		delete(object, "uploader")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AppBuild to handle AdditionalProperties
func (a AppBuild) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["account"], err = json.Marshal(a.Account)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'account': %w", err)
	}

	if a.Analyzed != nil {
		object["analyzed"], err = json.Marshal(a.Analyzed)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'analyzed': %w", err)
		}
	}

	object["created"], err = json.Marshal(a.Created)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created': %w", err)
	}

	object["digest"], err = json.Marshal(a.Digest)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'digest': %w", err)
	}

	if a.DownloadedAppstoreApplicationKey != nil {
		object["downloaded_appstore_application_key"], err = json.Marshal(a.DownloadedAppstoreApplicationKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'downloaded_appstore_application_key': %w", err)
		}
	}

	object["group"], err = json.Marshal(a.Group)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'group': %w", err)
	}

	if a.Icon != nil {
		object["icon"], err = json.Marshal(a.Icon)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icon': %w", err)
		}
	}

	object["package"], err = json.Marshal(a.Package)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'package': %w", err)
	}

	if a.Platform != nil {
		object["platform"], err = json.Marshal(a.Platform)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'platform': %w", err)
		}
	}

	object["ref"], err = json.Marshal(a.Ref)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ref': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Uploaded != nil {
		object["uploaded"], err = json.Marshal(a.Uploaded)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uploaded': %w", err)
		}
	}

	if a.Uploader != nil {
		object["uploader"], err = json.Marshal(a.Uploader)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uploader': %w", err)
		}
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LabApp. Returns the specified
// element and whether it was found
func (a LabApp) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LabApp
func (a *LabApp) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LabApp to handle AdditionalProperties
func (a *LabApp) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["account"]; found {
		err = json.Unmarshal(raw, &a.Account)
		if err != nil {
			return fmt.Errorf("error reading 'account': %w", err)
		}
		delete(object, "account")
	}

	if raw, found := object["appstore_application_key"]; found {
		err = json.Unmarshal(raw, &a.AppstoreApplicationKey)
		if err != nil {
			return fmt.Errorf("error reading 'appstore_application_key': %w", err)
		}
		delete(object, "appstore_application_key")
	}

	if raw, found := object["archived_at"]; found {
		err = json.Unmarshal(raw, &a.ArchivedAt)
		if err != nil {
			return fmt.Errorf("error reading 'archived_at': %w", err)
		}
		delete(object, "archived_at")
	}

	if raw, found := object["binary"]; found {
		err = json.Unmarshal(raw, &a.Binary)
		if err != nil {
			return fmt.Errorf("error reading 'binary': %w", err)
		}
		delete(object, "binary")
	}

	if raw, found := object["config"]; found {
		err = json.Unmarshal(raw, &a.Config)
		if err != nil {
			return fmt.Errorf("error reading 'config': %w", err)
		}
		delete(object, "config")
	}

	if raw, found := object["config_level"]; found {
		err = json.Unmarshal(raw, &a.ConfigLevel)
		if err != nil {
			return fmt.Errorf("error reading 'config_level': %w", err)
		}
		delete(object, "config_level")
	}

	if raw, found := object["created"]; found {
		err = json.Unmarshal(raw, &a.Created)
		if err != nil {
			return fmt.Errorf("error reading 'created': %w", err)
		}
		delete(object, "created")
	}

	if raw, found := object["findings_overrides"]; found {
		err = json.Unmarshal(raw, &a.FindingsOverrides)
		if err != nil {
			return fmt.Errorf("error reading 'findings_overrides': %w", err)
		}
		delete(object, "findings_overrides")
	}

	if raw, found := object["forbidden"]; found {
		err = json.Unmarshal(raw, &a.Forbidden)
		if err != nil {
			return fmt.Errorf("error reading 'forbidden': %w", err)
		}
		delete(object, "forbidden")
	}

	if raw, found := object["group"]; found {
		err = json.Unmarshal(raw, &a.Group)
		if err != nil {
			return fmt.Errorf("error reading 'group': %w", err)
		}
		delete(object, "group")
	}

	if raw, found := object["integrations"]; found {
		err = json.Unmarshal(raw, &a.Integrations)
		if err != nil {
			return fmt.Errorf("error reading 'integrations': %w", err)
		}
		delete(object, "integrations")
	}

	if raw, found := object["package"]; found {
		err = json.Unmarshal(raw, &a.Package)
		if err != nil {
			return fmt.Errorf("error reading 'package': %w", err)
		}
		delete(object, "package")
	}

	if raw, found := object["platform"]; found {
		err = json.Unmarshal(raw, &a.Platform)
		if err != nil {
			return fmt.Errorf("error reading 'platform': %w", err)
		}
		delete(object, "platform")
	}

	if raw, found := object["ref"]; found {
		err = json.Unmarshal(raw, &a.Ref)
		if err != nil {
			return fmt.Errorf("error reading 'ref': %w", err)
		}
		delete(object, "ref")
	}

	if raw, found := object["test_runner_binary"]; found {
		err = json.Unmarshal(raw, &a.TestRunnerBinary)
		if err != nil {
			return fmt.Errorf("error reading 'test_runner_binary': %w", err)
		}
		delete(object, "test_runner_binary")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LabApp to handle AdditionalProperties
func (a LabApp) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["account"], err = json.Marshal(a.Account)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'account': %w", err)
	}

	if a.AppstoreApplicationKey != nil {
		object["appstore_application_key"], err = json.Marshal(a.AppstoreApplicationKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appstore_application_key': %w", err)
		}
	}

	if a.ArchivedAt != nil {
		object["archived_at"], err = json.Marshal(a.ArchivedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'archived_at': %w", err)
		}
	}

	if a.Binary != nil {
		object["binary"], err = json.Marshal(a.Binary)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'binary': %w", err)
		}
	}

	if a.Config != nil {
		object["config"], err = json.Marshal(a.Config)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config': %w", err)
		}
	}

	if a.ConfigLevel != nil {
		object["config_level"], err = json.Marshal(a.ConfigLevel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_level': %w", err)
		}
	}

	if a.Created != nil {
		object["created"], err = json.Marshal(a.Created)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created': %w", err)
		}
	}

	if a.FindingsOverrides != nil {
		object["findings_overrides"], err = json.Marshal(a.FindingsOverrides)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'findings_overrides': %w", err)
		}
	}

	if a.Forbidden != nil {
		object["forbidden"], err = json.Marshal(a.Forbidden)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'forbidden': %w", err)
		}
	}

	object["group"], err = json.Marshal(a.Group)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'group': %w", err)
	}

	if a.Integrations != nil {
		object["integrations"], err = json.Marshal(a.Integrations)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'integrations': %w", err)
		}
	}

	object["package"], err = json.Marshal(a.Package)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'package': %w", err)
	}

	object["platform"], err = json.Marshal(a.Platform)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'platform': %w", err)
	}

	object["ref"], err = json.Marshal(a.Ref)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ref': %w", err)
	}

	if a.TestRunnerBinary != nil {
		object["test_runner_binary"], err = json.Marshal(a.TestRunnerBinary)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'test_runner_binary': %w", err)
		}
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LabRouteError. Returns the specified
// element and whether it was found
func (a LabRouteError) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LabRouteError
func (a *LabRouteError) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LabRouteError to handle AdditionalProperties
func (a *LabRouteError) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LabRouteError to handle AdditionalProperties
func (a LabRouteError) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Message != nil {
		object["message"], err = json.Marshal(a.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StandardError. Returns the specified
// element and whether it was found
func (a StandardError) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StandardError
func (a *StandardError) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StandardError to handle AdditionalProperties
func (a *StandardError) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["errors"]; found {
		err = json.Unmarshal(raw, &a.Errors)
		if err != nil {
			return fmt.Errorf("error reading 'errors': %w", err)
		}
		delete(object, "errors")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StandardError to handle AdditionalProperties
func (a StandardError) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Code != nil {
		object["code"], err = json.Marshal(a.Code)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'code': %w", err)
		}
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	if a.Errors != nil {
		object["errors"], err = json.Marshal(a.Errors)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'errors': %w", err)
		}
	}

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsLabAppConfigDynamic0 returns the union data inside the LabApp_Config_Dynamic as a LabAppConfigDynamic0
func (t LabApp_Config_Dynamic) AsLabAppConfigDynamic0() (LabAppConfigDynamic0, error) {
	var body LabAppConfigDynamic0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLabAppConfigDynamic0 overwrites any union data inside the LabApp_Config_Dynamic as the provided LabAppConfigDynamic0
func (t *LabApp_Config_Dynamic) FromLabAppConfigDynamic0(v LabAppConfigDynamic0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLabAppConfigDynamic0 performs a merge with any union data inside the LabApp_Config_Dynamic, using the provided LabAppConfigDynamic0
func (t *LabApp_Config_Dynamic) MergeLabAppConfigDynamic0(v LabAppConfigDynamic0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLabAppConfigDynamic1 returns the union data inside the LabApp_Config_Dynamic as a LabAppConfigDynamic1
func (t LabApp_Config_Dynamic) AsLabAppConfigDynamic1() (LabAppConfigDynamic1, error) {
	var body LabAppConfigDynamic1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLabAppConfigDynamic1 overwrites any union data inside the LabApp_Config_Dynamic as the provided LabAppConfigDynamic1
func (t *LabApp_Config_Dynamic) FromLabAppConfigDynamic1(v LabAppConfigDynamic1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLabAppConfigDynamic1 performs a merge with any union data inside the LabApp_Config_Dynamic, using the provided LabAppConfigDynamic1
func (t *LabApp_Config_Dynamic) MergeLabAppConfigDynamic1(v LabAppConfigDynamic1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLabAppConfigDynamic2 returns the union data inside the LabApp_Config_Dynamic as a LabAppConfigDynamic2
func (t LabApp_Config_Dynamic) AsLabAppConfigDynamic2() (LabAppConfigDynamic2, error) {
	var body LabAppConfigDynamic2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLabAppConfigDynamic2 overwrites any union data inside the LabApp_Config_Dynamic as the provided LabAppConfigDynamic2
func (t *LabApp_Config_Dynamic) FromLabAppConfigDynamic2(v LabAppConfigDynamic2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLabAppConfigDynamic2 performs a merge with any union data inside the LabApp_Config_Dynamic, using the provided LabAppConfigDynamic2
func (t *LabApp_Config_Dynamic) MergeLabAppConfigDynamic2(v LabAppConfigDynamic2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LabApp_Config_Dynamic) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LabApp_Config_Dynamic) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLabAppConfigStatic0 returns the union data inside the LabApp_Config_Static as a LabAppConfigStatic0
func (t LabApp_Config_Static) AsLabAppConfigStatic0() (LabAppConfigStatic0, error) {
	var body LabAppConfigStatic0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLabAppConfigStatic0 overwrites any union data inside the LabApp_Config_Static as the provided LabAppConfigStatic0
func (t *LabApp_Config_Static) FromLabAppConfigStatic0(v LabAppConfigStatic0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLabAppConfigStatic0 performs a merge with any union data inside the LabApp_Config_Static, using the provided LabAppConfigStatic0
func (t *LabApp_Config_Static) MergeLabAppConfigStatic0(v LabAppConfigStatic0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLabAppConfigStatic1 returns the union data inside the LabApp_Config_Static as a LabAppConfigStatic1
func (t LabApp_Config_Static) AsLabAppConfigStatic1() (LabAppConfigStatic1, error) {
	var body LabAppConfigStatic1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLabAppConfigStatic1 overwrites any union data inside the LabApp_Config_Static as the provided LabAppConfigStatic1
func (t *LabApp_Config_Static) FromLabAppConfigStatic1(v LabAppConfigStatic1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLabAppConfigStatic1 performs a merge with any union data inside the LabApp_Config_Static, using the provided LabAppConfigStatic1
func (t *LabApp_Config_Static) MergeLabAppConfigStatic1(v LabAppConfigStatic1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLabAppConfigStatic2 returns the union data inside the LabApp_Config_Static as a LabAppConfigStatic2
func (t LabApp_Config_Static) AsLabAppConfigStatic2() (LabAppConfigStatic2, error) {
	var body LabAppConfigStatic2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLabAppConfigStatic2 overwrites any union data inside the LabApp_Config_Static as the provided LabAppConfigStatic2
func (t *LabApp_Config_Static) FromLabAppConfigStatic2(v LabAppConfigStatic2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLabAppConfigStatic2 performs a merge with any union data inside the LabApp_Config_Static, using the provided LabAppConfigStatic2
func (t *LabApp_Config_Static) MergeLabAppConfigStatic2(v LabAppConfigStatic2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LabApp_Config_Static) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LabApp_Config_Static) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccountUser request
	GetAccountUser(ctx context.Context, params *GetAccountUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountUserRef request
	GetAccountUserRef(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppWithBody request with any body
	PostAppWithBody(ctx context.Context, params *PostAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApp(ctx context.Context, params *PostAppParams, body PostAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackage request
	GetAppPlatformPackage(ctx context.Context, platform GetAppPlatformPackageParamsPlatform, pPackage string, params *GetAppPlatformPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageAssessment request
	GetAppPlatformPackageAssessment(ctx context.Context, platform GetAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *GetAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppPlatformPackageAssessment request
	PostAppPlatformPackageAssessment(ctx context.Context, platform PostAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *PostAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageAssessmentTask request
	GetAppPlatformPackageAssessmentTask(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageAssessmentTaskRaw request
	GetAppPlatformPackageAssessmentTaskRaw(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskRawParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskRawParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppPlatformPackageAssessmentTaskCancel request
	PostAppPlatformPackageAssessmentTaskCancel(ctx context.Context, platform PostAppPlatformPackageAssessmentTaskCancelParamsPlatform, pPackage string, task float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageAssessmentTaskReport request
	GetAppPlatformPackageAssessmentTaskReport(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskReportParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageAssessmentTaskResults request
	GetAppPlatformPackageAssessmentTaskResults(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskResultsParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppPlatformPackageBinary request
	PostAppPlatformPackageBinary(ctx context.Context, platform PostAppPlatformPackageBinaryParamsPlatform, pPackage string, params *PostAppPlatformPackageBinaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageBuild request
	GetAppPlatformPackageBuild(ctx context.Context, platform GetAppPlatformPackageBuildParamsPlatform, pPackage string, params *GetAppPlatformPackageBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppPlatformPackageConfig request
	GetAppPlatformPackageConfig(ctx context.Context, platform GetAppPlatformPackageConfigParamsPlatform, pPackage string, params *GetAppPlatformPackageConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppPlatformPackageConfigWithBody request with any body
	PostAppPlatformPackageConfigWithBody(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppPlatformPackageConfig(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, body PostAppPlatformPackageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppPlatformPackageRunner request
	DeleteAppPlatformPackageRunner(ctx context.Context, platform DeleteAppPlatformPackageRunnerParamsPlatform, pPackage string, params *DeleteAppPlatformPackageRunnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppPlatformPackageRunnerWithBody request with any body
	PostAppPlatformPackageRunnerWithBody(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAppPlatformPackageRunner(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, body PostAppPlatformPackageRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssessmentRefReportHtml request
	GetAssessmentRefReportHtml(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssessmentRefReportJson request
	GetAssessmentRefReportJson(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssessmentRefReportPdf request
	GetAssessmentRefReportPdf(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssessmentTaskFindings request
	GetAssessmentTaskFindings(ctx context.Context, task float32, params *GetAssessmentTaskFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssessmentTaskSummary request
	GetAssessmentTaskSummary(ctx context.Context, task float32, params *GetAssessmentTaskSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBinaryWithBody request with any body
	PostBinaryWithBody(ctx context.Context, params *PostBinaryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBinary(ctx context.Context, params *PostBinaryParams, body PostBinaryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinaryDigestAnalysis request
	GetBinaryDigestAnalysis(ctx context.Context, digest string, params *GetBinaryDigestAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuild request
	GetBuild(ctx context.Context, params *GetBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBuildWithBody request with any body
	PostBuildWithBody(ctx context.Context, params *PostBuildParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBuild(ctx context.Context, params *PostBuildParams, body PostBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBuildPlatformPackageWithBody request with any body
	PostBuildPlatformPackageWithBody(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBuildPlatformPackage(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, body PostBuildPlatformPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLoginToken request
	PostLoginToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRef request
	PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRef(ctx context.Context, appRef openapi_types.UUID, currentGroupRef openapi_types.UUID, newGroupRef openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserToken request
	GetUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserTokenWithBody request with any body
	PostUserTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUserToken(ctx context.Context, body PostUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserTokenRefreshWithBody request with any body
	PostUserTokenRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUserTokenRefresh(ctx context.Context, body PostUserTokenRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccountUser(ctx context.Context, params *GetAccountUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountUserRef(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountUserRefRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppWithBody(ctx context.Context, params *PostAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApp(ctx context.Context, params *PostAppParams, body PostAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackage(ctx context.Context, platform GetAppPlatformPackageParamsPlatform, pPackage string, params *GetAppPlatformPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageAssessment(ctx context.Context, platform GetAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *GetAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageAssessmentRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageAssessment(ctx context.Context, platform PostAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *PostAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageAssessmentRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageAssessmentTask(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageAssessmentTaskRequest(c.Server, platform, pPackage, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageAssessmentTaskRaw(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskRawParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskRawParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageAssessmentTaskRawRequest(c.Server, platform, pPackage, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageAssessmentTaskCancel(ctx context.Context, platform PostAppPlatformPackageAssessmentTaskCancelParamsPlatform, pPackage string, task float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageAssessmentTaskCancelRequest(c.Server, platform, pPackage, task)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageAssessmentTaskReport(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskReportParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageAssessmentTaskReportRequest(c.Server, platform, pPackage, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageAssessmentTaskResults(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskResultsParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageAssessmentTaskResultsRequest(c.Server, platform, pPackage, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageBinary(ctx context.Context, platform PostAppPlatformPackageBinaryParamsPlatform, pPackage string, params *PostAppPlatformPackageBinaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageBinaryRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageBuild(ctx context.Context, platform GetAppPlatformPackageBuildParamsPlatform, pPackage string, params *GetAppPlatformPackageBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageBuildRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppPlatformPackageConfig(ctx context.Context, platform GetAppPlatformPackageConfigParamsPlatform, pPackage string, params *GetAppPlatformPackageConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppPlatformPackageConfigRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageConfigWithBody(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageConfigRequestWithBody(c.Server, platform, pPackage, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageConfig(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, body PostAppPlatformPackageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageConfigRequest(c.Server, platform, pPackage, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppPlatformPackageRunner(ctx context.Context, platform DeleteAppPlatformPackageRunnerParamsPlatform, pPackage string, params *DeleteAppPlatformPackageRunnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppPlatformPackageRunnerRequest(c.Server, platform, pPackage, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageRunnerWithBody(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageRunnerRequestWithBody(c.Server, platform, pPackage, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppPlatformPackageRunner(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, body PostAppPlatformPackageRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppPlatformPackageRunnerRequest(c.Server, platform, pPackage, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssessmentRefReportHtml(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssessmentRefReportHtmlRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssessmentRefReportJson(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssessmentRefReportJsonRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssessmentRefReportPdf(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssessmentRefReportPdfRequest(c.Server, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssessmentTaskFindings(ctx context.Context, task float32, params *GetAssessmentTaskFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssessmentTaskFindingsRequest(c.Server, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssessmentTaskSummary(ctx context.Context, task float32, params *GetAssessmentTaskSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssessmentTaskSummaryRequest(c.Server, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBinaryWithBody(ctx context.Context, params *PostBinaryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBinaryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBinary(ctx context.Context, params *PostBinaryParams, body PostBinaryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBinaryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBinaryDigestAnalysis(ctx context.Context, digest string, params *GetBinaryDigestAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinaryDigestAnalysisRequest(c.Server, digest, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuild(ctx context.Context, params *GetBuildParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBuildWithBody(ctx context.Context, params *PostBuildParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBuildRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBuild(ctx context.Context, params *PostBuildParams, body PostBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBuildRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBuildPlatformPackageWithBody(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBuildPlatformPackageRequestWithBody(c.Server, platform, pPackage, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBuildPlatformPackage(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, body PostBuildPlatformPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBuildPlatformPackageRequest(c.Server, platform, pPackage, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLoginToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLoginTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRef(ctx context.Context, appRef openapi_types.UUID, currentGroupRef openapi_types.UUID, newGroupRef openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefRequest(c.Server, appRef, currentGroupRef, newGroupRef)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserToken(ctx context.Context, body PostUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTokenRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTokenRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserTokenRefresh(ctx context.Context, body PostUserTokenRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserTokenRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountUserRequest generates requests for GetAccountUser
func NewGetAccountUserRequest(server string, params *GetAccountUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, *params.Domain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeRole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_role", runtime.ParamLocationQuery, *params.ExcludeRole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountUserRefRequest generates requests for GetAccountUserRef
func NewGetAccountUserRefRequest(server string, ref openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, params *GetAppParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Platform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platform", runtime.ParamLocationQuery, *params.Platform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Package != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package", runtime.ParamLocationQuery, *params.Package); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppRequest calls the generic PostApp builder with application/json body
func NewPostAppRequest(server string, params *PostAppParams, body PostAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAppRequestWithBody generates requests for PostApp with any type of body
func NewPostAppRequestWithBody(server string, params *PostAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppPlatformPackageRequest generates requests for GetAppPlatformPackage
func NewGetAppPlatformPackageRequest(server string, platform GetAppPlatformPackageParamsPlatform, pPackage string, params *GetAppPlatformPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageAssessmentRequest generates requests for GetAppPlatformPackageAssessment
func NewGetAppPlatformPackageAssessmentRequest(server string, platform GetAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *GetAppPlatformPackageAssessmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppPlatformPackageAssessmentRequest generates requests for PostAppPlatformPackageAssessment
func NewPostAppPlatformPackageAssessmentRequest(server string, platform PostAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *PostAppPlatformPackageAssessmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppstoreDownload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appstore_download", runtime.ParamLocationQuery, *params.AppstoreDownload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Failfast != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "failfast", runtime.ParamLocationQuery, *params.Failfast); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnalysisType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "analysisType", runtime.ParamLocationQuery, *params.AnalysisType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideSensitiveDataValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hideSensitiveDataValues", runtime.ParamLocationQuery, *params.HideSensitiveDataValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageAssessmentTaskRequest generates requests for GetAppPlatformPackageAssessmentTask
func NewGetAppPlatformPackageAssessmentTaskRequest(server string, platform GetAppPlatformPackageAssessmentTaskParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageAssessmentTaskRawRequest generates requests for GetAppPlatformPackageAssessmentTaskRaw
func NewGetAppPlatformPackageAssessmentTaskRawRequest(server string, platform GetAppPlatformPackageAssessmentTaskRawParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskRawParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment/%s/_raw", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppPlatformPackageAssessmentTaskCancelRequest generates requests for PostAppPlatformPackageAssessmentTaskCancel
func NewPostAppPlatformPackageAssessmentTaskCancelRequest(server string, platform PostAppPlatformPackageAssessmentTaskCancelParamsPlatform, pPackage string, task float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment/%s/cancel", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageAssessmentTaskReportRequest generates requests for GetAppPlatformPackageAssessmentTaskReport
func NewGetAppPlatformPackageAssessmentTaskReportRequest(server string, platform GetAppPlatformPackageAssessmentTaskReportParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment/%s/report", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageAssessmentTaskResultsRequest generates requests for GetAppPlatformPackageAssessmentTaskResults
func NewGetAppPlatformPackageAssessmentTaskResultsRequest(server string, platform GetAppPlatformPackageAssessmentTaskResultsParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskResultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/assessment/%s/results", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppPlatformPackageBinaryRequest generates requests for PostAppPlatformPackageBinary
func NewPostAppPlatformPackageBinaryRequest(server string, platform PostAppPlatformPackageBinaryParamsPlatform, pPackage string, params *PostAppPlatformPackageBinaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/binary", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageBuildRequest generates requests for GetAppPlatformPackageBuild
func NewGetAppPlatformPackageBuildRequest(server string, platform GetAppPlatformPackageBuildParamsPlatform, pPackage string, params *GetAppPlatformPackageBuildParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/build", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppPlatformPackageConfigRequest generates requests for GetAppPlatformPackageConfig
func NewGetAppPlatformPackageConfigRequest(server string, platform GetAppPlatformPackageConfigParamsPlatform, pPackage string, params *GetAppPlatformPackageConfigParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/config", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppPlatformPackageConfigRequest calls the generic PostAppPlatformPackageConfig builder with application/json body
func NewPostAppPlatformPackageConfigRequest(server string, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, body PostAppPlatformPackageConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppPlatformPackageConfigRequestWithBody(server, platform, pPackage, params, "application/json", bodyReader)
}

// NewPostAppPlatformPackageConfigRequestWithBody generates requests for PostAppPlatformPackageConfig with any type of body
func NewPostAppPlatformPackageConfigRequestWithBody(server string, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/config", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppPlatformPackageRunnerRequest generates requests for DeleteAppPlatformPackageRunner
func NewDeleteAppPlatformPackageRunnerRequest(server string, platform DeleteAppPlatformPackageRunnerParamsPlatform, pPackage string, params *DeleteAppPlatformPackageRunnerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/runner", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppPlatformPackageRunnerRequest calls the generic PostAppPlatformPackageRunner builder with application/json body
func NewPostAppPlatformPackageRunnerRequest(server string, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, body PostAppPlatformPackageRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppPlatformPackageRunnerRequestWithBody(server, platform, pPackage, params, "application/json", bodyReader)
}

// NewPostAppPlatformPackageRunnerRequestWithBody generates requests for PostAppPlatformPackageRunner with any type of body
func NewPostAppPlatformPackageRunnerRequestWithBody(server string, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/%s/runner", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssessmentRefReportHtmlRequest generates requests for GetAssessmentRefReportHtml
func NewGetAssessmentRefReportHtmlRequest(server string, ref openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assessment/%s/report.html", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssessmentRefReportJsonRequest generates requests for GetAssessmentRefReportJson
func NewGetAssessmentRefReportJsonRequest(server string, ref openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assessment/%s/report.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssessmentRefReportPdfRequest generates requests for GetAssessmentRefReportPdf
func NewGetAssessmentRefReportPdfRequest(server string, ref openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assessment/%s/report.pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssessmentTaskFindingsRequest generates requests for GetAssessmentTaskFindings
func NewGetAssessmentTaskFindingsRequest(server string, task float32, params *GetAssessmentTaskFindingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assessment/%s/findings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsingLegacy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "using_legacy", runtime.ParamLocationQuery, *params.UsingLegacy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Report != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "report", runtime.ParamLocationQuery, *params.Report); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssessmentTaskSummaryRequest generates requests for GetAssessmentTaskSummary
func NewGetAssessmentTaskSummaryRequest(server string, task float32, params *GetAssessmentTaskSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assessment/%s/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBinaryRequest calls the generic PostBinary builder with application/json body
func NewPostBinaryRequest(server string, params *PostBinaryParams, body PostBinaryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBinaryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostBinaryRequestWithBody generates requests for PostBinary with any type of body
func NewPostBinaryRequestWithBody(server string, params *PostBinaryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/binary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBinaryDigestAnalysisRequest generates requests for GetBinaryDigestAnalysis
func NewGetBinaryDigestAnalysisRequest(server string, digest string, params *GetBinaryDigestAnalysisParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "digest", runtime.ParamLocationPath, digest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/binary/%s/analysis", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeStatusEvents", runtime.ParamLocationQuery, params.IncludeStatusEvents); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildRequest generates requests for GetBuild
func NewGetBuildRequest(server string, params *GetBuildParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBuildRequest calls the generic PostBuild builder with application/json body
func NewPostBuildRequest(server string, params *PostBuildParams, body PostBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBuildRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostBuildRequestWithBody generates requests for PostBuild with any type of body
func NewPostBuildRequestWithBody(server string, params *PostBuildParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AnalysisType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "analysisType", runtime.ParamLocationQuery, *params.AnalysisType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Assessment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assessment", runtime.ParamLocationQuery, *params.Assessment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideSensitiveDataValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hideSensitiveDataValues", runtime.ParamLocationQuery, *params.HideSensitiveDataValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBuildPlatformPackageRequest calls the generic PostBuildPlatformPackage builder with application/json body
func NewPostBuildPlatformPackageRequest(server string, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, body PostBuildPlatformPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBuildPlatformPackageRequestWithBody(server, platform, pPackage, params, "application/json", bodyReader)
}

// NewPostBuildPlatformPackageRequestWithBody generates requests for PostBuildPlatformPackage with any type of body
func NewPostBuildPlatformPackageRequestWithBody(server string, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostLoginTokenRequest generates requests for PostLoginToken
func NewPostLoginTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefRequest generates requests for PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRef
func NewPostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefRequest(server string, appRef openapi_types.UUID, currentGroupRef openapi_types.UUID, newGroupRef openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appRef", runtime.ParamLocationPath, appRef)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "currentGroupRef", runtime.ParamLocationPath, currentGroupRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "newGroupRef", runtime.ParamLocationPath, newGroupRef)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource/_change_app_group/%s/from/%s/to/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserTokenRequest generates requests for GetUserToken
func NewGetUserTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUserTokenRequest calls the generic PostUserToken builder with application/json body
func NewPostUserTokenRequest(server string, body PostUserTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUserTokenRequestWithBody generates requests for PostUserToken with any type of body
func NewPostUserTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUserTokenRefreshRequest calls the generic PostUserTokenRefresh builder with application/json body
func NewPostUserTokenRefreshRequest(server string, body PostUserTokenRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserTokenRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUserTokenRefreshRequestWithBody generates requests for PostUserTokenRefresh with any type of body
func NewPostUserTokenRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountUserWithResponse request
	GetAccountUserWithResponse(ctx context.Context, params *GetAccountUserParams, reqEditors ...RequestEditorFn) (*GetAccountUserResponse, error)

	// GetAccountUserRefWithResponse request
	GetAccountUserRefWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAccountUserRefResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// PostAppWithBodyWithResponse request with any body
	PostAppWithBodyWithResponse(ctx context.Context, params *PostAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppResponse, error)

	PostAppWithResponse(ctx context.Context, params *PostAppParams, body PostAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppResponse, error)

	// GetAppPlatformPackageWithResponse request
	GetAppPlatformPackageWithResponse(ctx context.Context, platform GetAppPlatformPackageParamsPlatform, pPackage string, params *GetAppPlatformPackageParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageResponse, error)

	// GetAppPlatformPackageAssessmentWithResponse request
	GetAppPlatformPackageAssessmentWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *GetAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentResponse, error)

	// PostAppPlatformPackageAssessmentWithResponse request
	PostAppPlatformPackageAssessmentWithResponse(ctx context.Context, platform PostAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *PostAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageAssessmentResponse, error)

	// GetAppPlatformPackageAssessmentTaskWithResponse request
	GetAppPlatformPackageAssessmentTaskWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskResponse, error)

	// GetAppPlatformPackageAssessmentTaskRawWithResponse request
	GetAppPlatformPackageAssessmentTaskRawWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskRawParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskRawParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskRawResponse, error)

	// PostAppPlatformPackageAssessmentTaskCancelWithResponse request
	PostAppPlatformPackageAssessmentTaskCancelWithResponse(ctx context.Context, platform PostAppPlatformPackageAssessmentTaskCancelParamsPlatform, pPackage string, task float32, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageAssessmentTaskCancelResponse, error)

	// GetAppPlatformPackageAssessmentTaskReportWithResponse request
	GetAppPlatformPackageAssessmentTaskReportWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskReportParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskReportParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskReportResponse, error)

	// GetAppPlatformPackageAssessmentTaskResultsWithResponse request
	GetAppPlatformPackageAssessmentTaskResultsWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskResultsParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskResultsParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskResultsResponse, error)

	// PostAppPlatformPackageBinaryWithResponse request
	PostAppPlatformPackageBinaryWithResponse(ctx context.Context, platform PostAppPlatformPackageBinaryParamsPlatform, pPackage string, params *PostAppPlatformPackageBinaryParams, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageBinaryResponse, error)

	// GetAppPlatformPackageBuildWithResponse request
	GetAppPlatformPackageBuildWithResponse(ctx context.Context, platform GetAppPlatformPackageBuildParamsPlatform, pPackage string, params *GetAppPlatformPackageBuildParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageBuildResponse, error)

	// GetAppPlatformPackageConfigWithResponse request
	GetAppPlatformPackageConfigWithResponse(ctx context.Context, platform GetAppPlatformPackageConfigParamsPlatform, pPackage string, params *GetAppPlatformPackageConfigParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageConfigResponse, error)

	// PostAppPlatformPackageConfigWithBodyWithResponse request with any body
	PostAppPlatformPackageConfigWithBodyWithResponse(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageConfigResponse, error)

	PostAppPlatformPackageConfigWithResponse(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, body PostAppPlatformPackageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageConfigResponse, error)

	// DeleteAppPlatformPackageRunnerWithResponse request
	DeleteAppPlatformPackageRunnerWithResponse(ctx context.Context, platform DeleteAppPlatformPackageRunnerParamsPlatform, pPackage string, params *DeleteAppPlatformPackageRunnerParams, reqEditors ...RequestEditorFn) (*DeleteAppPlatformPackageRunnerResponse, error)

	// PostAppPlatformPackageRunnerWithBodyWithResponse request with any body
	PostAppPlatformPackageRunnerWithBodyWithResponse(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageRunnerResponse, error)

	PostAppPlatformPackageRunnerWithResponse(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, body PostAppPlatformPackageRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageRunnerResponse, error)

	// GetAssessmentRefReportHtmlWithResponse request
	GetAssessmentRefReportHtmlWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssessmentRefReportHtmlResponse, error)

	// GetAssessmentRefReportJsonWithResponse request
	GetAssessmentRefReportJsonWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssessmentRefReportJsonResponse, error)

	// GetAssessmentRefReportPdfWithResponse request
	GetAssessmentRefReportPdfWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssessmentRefReportPdfResponse, error)

	// GetAssessmentTaskFindingsWithResponse request
	GetAssessmentTaskFindingsWithResponse(ctx context.Context, task float32, params *GetAssessmentTaskFindingsParams, reqEditors ...RequestEditorFn) (*GetAssessmentTaskFindingsResponse, error)

	// GetAssessmentTaskSummaryWithResponse request
	GetAssessmentTaskSummaryWithResponse(ctx context.Context, task float32, params *GetAssessmentTaskSummaryParams, reqEditors ...RequestEditorFn) (*GetAssessmentTaskSummaryResponse, error)

	// PostBinaryWithBodyWithResponse request with any body
	PostBinaryWithBodyWithResponse(ctx context.Context, params *PostBinaryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBinaryResponse, error)

	PostBinaryWithResponse(ctx context.Context, params *PostBinaryParams, body PostBinaryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBinaryResponse, error)

	// GetBinaryDigestAnalysisWithResponse request
	GetBinaryDigestAnalysisWithResponse(ctx context.Context, digest string, params *GetBinaryDigestAnalysisParams, reqEditors ...RequestEditorFn) (*GetBinaryDigestAnalysisResponse, error)

	// GetBuildWithResponse request
	GetBuildWithResponse(ctx context.Context, params *GetBuildParams, reqEditors ...RequestEditorFn) (*GetBuildResponse, error)

	// PostBuildWithBodyWithResponse request with any body
	PostBuildWithBodyWithResponse(ctx context.Context, params *PostBuildParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBuildResponse, error)

	PostBuildWithResponse(ctx context.Context, params *PostBuildParams, body PostBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBuildResponse, error)

	// PostBuildPlatformPackageWithBodyWithResponse request with any body
	PostBuildPlatformPackageWithBodyWithResponse(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBuildPlatformPackageResponse, error)

	PostBuildPlatformPackageWithResponse(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, body PostBuildPlatformPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBuildPlatformPackageResponse, error)

	// PostLoginTokenWithResponse request
	PostLoginTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostLoginTokenResponse, error)

	// PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefWithResponse request
	PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefWithResponse(ctx context.Context, appRef openapi_types.UUID, currentGroupRef openapi_types.UUID, newGroupRef openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse, error)

	// GetUserTokenWithResponse request
	GetUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserTokenResponse, error)

	// PostUserTokenWithBodyWithResponse request with any body
	PostUserTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTokenResponse, error)

	PostUserTokenWithResponse(ctx context.Context, body PostUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTokenResponse, error)

	// PostUserTokenRefreshWithBodyWithResponse request with any body
	PostUserTokenRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTokenRefreshResponse, error)

	PostUserTokenRefreshWithResponse(ctx context.Context, body PostUserTokenRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTokenRefreshResponse, error)
}

type GetAccountUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]struct {
		// Active The active state of the user.
		Active bool `json:"active"`

		// AllCapabilities The list of capabilities available to the user.
		AllCapabilities []struct {
			// Actions The verb actions this capability grants.
			Actions []string `json:"actions"`

			// Category The category grouping of the capability.
			Category *string `json:"category"`

			// CreatedAt The date-time this capability was created.
			CreatedAt time.Time `json:"createdAt"`

			// Id The unique numeric identifier for the capability.
			Id int `json:"id"`

			// Label The short descriptive label for the capability.
			Label string `json:"label"`

			// Namespace The wider grouping of the resource this capability relates to.
			Namespace string `json:"namespace"`

			// Privileges The list of privileges granted by this capability.
			Privileges []string `json:"privileges"`

			// Ref The unique identifier for the capability.
			Ref openapi_types.UUID `json:"ref"`

			// ResourceType The type of entity/resource this capability relates to.
			ResourceType string `json:"resource_type"`

			// Scope The level of access this capability grants to the resource it relates to.
			Scope *string `json:"scope"`

			// UpdatedAt The date-time this capability was last updated.
			UpdatedAt time.Time `json:"updatedAt"`
		} `json:"all_capabilities"`

		// AvatarUrl The URL of the user's avatar image.
		AvatarUrl    *string       `json:"avatar_url"`
		Capabilities []interface{} `json:"capabilities"`

		// CreatedAt The date-time the user was created.
		CreatedAt time.Time `json:"created_at"`

		// Email The email address of the user.
		Email *string `json:"email"`

		// GroupRefs The UUID refs for the groups the user was added to when they were invited.
		GroupRefs *[]openapi_types.UUID `json:"groupRefs"`

		// Groups The list of groups the user is a member of.
		Groups []struct {
			// Active The active state of the group.
			Active bool `json:"active"`

			// CreatedAt The date-time the group was created.
			CreatedAt time.Time `json:"createdAt"`

			// DeletedAt The date-time this group was soft-deleted.
			DeletedAt time.Time `json:"deleted_at"`

			// Id The unique numeric identifier for the group.
			Id int `json:"id"`

			// Name The name of the group.
			Name string `json:"name"`

			// Note An optional note assigned to the group.
			Note *string `json:"note"`

			// OrganizationId The numeric ID of the organization this group belongs to.
			OrganizationId int `json:"organizationId"`

			// Ref The unique identifier for the group.
			Ref openapi_types.UUID `json:"ref"`

			// UpdatedAt The date-time this group was last updated.
			UpdatedAt time.Time `json:"updatedAt"`

			// UpdatedBy The UUID ref of the user who last updated this group.
			UpdatedBy *openapi_types.UUID `json:"updated_by"`
		} `json:"groups"`

		// Id The unique numeric identifier for the user.
		Id int `json:"id"`

		// Name The name of the user.
		Name string `json:"name"`

		// Note An optional note assigned to the user.
		Note *string `json:"note"`

		// OrganizationId The numeric ID of the organization the user belongs to.
		OrganizationId int `json:"organizationId"`

		// Privileges The list of permission strings for the capabilities available to the user.
		Privileges []string `json:"privileges"`

		// Ref The unique identifier for the user.
		Ref openapi_types.UUID `json:"ref"`

		// RoleRef The UUID ref of the role the user was assigned when they were invited.
		RoleRef *openapi_types.UUID `json:"roleRef"`

		// Roles The list of roles assigned to the user.
		Roles []struct {
			// AllCapabilities The list of capabilities available to this role.
			AllCapabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"all_capabilities"`

			// Capabilities The list of capabilities available to this role.
			Capabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"capabilities"`

			// CreatedAt The date-time the role was created.
			CreatedAt time.Time `json:"created_at"`

			// DefaultLabel A short descriptive label for the role.
			DefaultLabel *string `json:"defaultLabel"`

			// DefaultPermissions The list of capabilities available to this role by default.
			DefaultPermissions []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"defaultPermissions"`

			// Description A short description of the role.
			Description *string `json:"description"`

			// Id The unique numeric identifier for the role.
			Id           int   `json:"id"`
			IsCustomized *bool `json:"isCustomized,omitempty"`

			// IsHidden Determines if the role is hidden.
			IsHidden *bool `json:"isHidden"`

			// IsCustomizable Determines if the role can be customized.
			IsCustomizable *bool `json:"is_customizable"`

			// IsInternal Determines if the role is internal.
			IsInternal *bool `json:"is_internal"`

			// Label A short descriptive label for the role.
			Label *string `json:"label"`

			// Name The name of the role.
			Name string `json:"name"`

			// OrgSettings The list of organization-level settings associated with this role.
			OrgSettings []map[string]interface{} `json:"org_settings"`

			// OrganizationCapabilities For a customized role, the list of capabilities available to this role.
			OrganizationCapabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"organization_capabilities"`

			// OrganizationId The numeric ID of the organization this group belongs to.
			OrganizationId *int `json:"organization_id"`

			// Permissions The list of capabilities available to this role.
			Permissions []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"permissions"`

			// Ref The unique identifier for the role.
			Ref openapi_types.UUID `json:"ref"`

			// UpdatedAt The date-time the role was last updated.
			UpdatedAt time.Time `json:"updated_at"`
		} `json:"roles"`

		// UpdatedAt The date-time the user was last updated.
		UpdatedAt time.Time `json:"updated_at"`

		// UpdatedBy The UUID ref of user who last updated the user.
		UpdatedBy *openapi_types.UUID `json:"updated_by"`

		// Username The username of the user.
		Username *string `json:"username"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAccountUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountUserRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Active The active state of the user.
		Active bool `json:"active"`

		// AllCapabilities The list of capabilities available to the user.
		AllCapabilities []struct {
			// Actions The verb actions this capability grants.
			Actions []string `json:"actions"`

			// Category The category grouping of the capability.
			Category *string `json:"category"`

			// CreatedAt The date-time this capability was created.
			CreatedAt time.Time `json:"createdAt"`

			// Id The unique numeric identifier for the capability.
			Id int `json:"id"`

			// Label The short descriptive label for the capability.
			Label string `json:"label"`

			// Namespace The wider grouping of the resource this capability relates to.
			Namespace string `json:"namespace"`

			// Privileges The list of privileges granted by this capability.
			Privileges []string `json:"privileges"`

			// Ref The unique identifier for the capability.
			Ref openapi_types.UUID `json:"ref"`

			// ResourceType The type of entity/resource this capability relates to.
			ResourceType string `json:"resource_type"`

			// Scope The level of access this capability grants to the resource it relates to.
			Scope *string `json:"scope"`

			// UpdatedAt The date-time this capability was last updated.
			UpdatedAt time.Time `json:"updatedAt"`
		} `json:"all_capabilities"`

		// AvatarUrl The URL of the user's avatar image.
		AvatarUrl    *string       `json:"avatar_url"`
		Capabilities []interface{} `json:"capabilities"`

		// CreatedAt The date-time the user was created.
		CreatedAt time.Time `json:"created_at"`

		// Email The email address of the user.
		Email *string `json:"email"`

		// GroupRefs The UUID refs for the groups the user was added to when they were invited.
		GroupRefs *[]openapi_types.UUID `json:"groupRefs"`

		// Groups The list of groups the user is a member of.
		Groups []struct {
			// Active The active state of the group.
			Active bool `json:"active"`

			// CreatedAt The date-time the group was created.
			CreatedAt time.Time `json:"createdAt"`

			// DeletedAt The date-time this group was soft-deleted.
			DeletedAt time.Time `json:"deleted_at"`

			// Id The unique numeric identifier for the group.
			Id int `json:"id"`

			// Name The name of the group.
			Name string `json:"name"`

			// Note An optional note assigned to the group.
			Note *string `json:"note"`

			// OrganizationId The numeric ID of the organization this group belongs to.
			OrganizationId int `json:"organizationId"`

			// Ref The unique identifier for the group.
			Ref openapi_types.UUID `json:"ref"`

			// UpdatedAt The date-time this group was last updated.
			UpdatedAt time.Time `json:"updatedAt"`

			// UpdatedBy The UUID ref of the user who last updated this group.
			UpdatedBy *openapi_types.UUID `json:"updated_by"`
		} `json:"groups"`

		// Id The unique numeric identifier for the user.
		Id int `json:"id"`

		// Name The name of the user.
		Name string `json:"name"`

		// Note An optional note assigned to the user.
		Note *string `json:"note"`

		// OrganizationId The numeric ID of the organization the user belongs to.
		OrganizationId int `json:"organizationId"`

		// Privileges The list of permission strings for the capabilities available to the user.
		Privileges []string `json:"privileges"`

		// Ref The unique identifier for the user.
		Ref openapi_types.UUID `json:"ref"`

		// RoleRef The UUID ref of the role the user was assigned when they were invited.
		RoleRef *openapi_types.UUID `json:"roleRef"`

		// Roles The list of roles assigned to the user.
		Roles []struct {
			// AllCapabilities The list of capabilities available to this role.
			AllCapabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"all_capabilities"`

			// Capabilities The list of capabilities available to this role.
			Capabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"capabilities"`

			// CreatedAt The date-time the role was created.
			CreatedAt time.Time `json:"created_at"`

			// DefaultLabel A short descriptive label for the role.
			DefaultLabel *string `json:"defaultLabel"`

			// DefaultPermissions The list of capabilities available to this role by default.
			DefaultPermissions []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"defaultPermissions"`

			// Description A short description of the role.
			Description *string `json:"description"`

			// Id The unique numeric identifier for the role.
			Id           int   `json:"id"`
			IsCustomized *bool `json:"isCustomized,omitempty"`

			// IsHidden Determines if the role is hidden.
			IsHidden *bool `json:"isHidden"`

			// IsCustomizable Determines if the role can be customized.
			IsCustomizable *bool `json:"is_customizable"`

			// IsInternal Determines if the role is internal.
			IsInternal *bool `json:"is_internal"`

			// Label A short descriptive label for the role.
			Label *string `json:"label"`

			// Name The name of the role.
			Name string `json:"name"`

			// OrgSettings The list of organization-level settings associated with this role.
			OrgSettings []map[string]interface{} `json:"org_settings"`

			// OrganizationCapabilities For a customized role, the list of capabilities available to this role.
			OrganizationCapabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"organization_capabilities"`

			// OrganizationId The numeric ID of the organization this group belongs to.
			OrganizationId *int `json:"organization_id"`

			// Permissions The list of capabilities available to this role.
			Permissions []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"permissions"`

			// Ref The unique identifier for the role.
			Ref openapi_types.UUID `json:"ref"`

			// UpdatedAt The date-time the role was last updated.
			UpdatedAt time.Time `json:"updated_at"`
		} `json:"roles"`

		// UpdatedAt The date-time the user was last updated.
		UpdatedAt time.Time `json:"updated_at"`

		// UpdatedBy The UUID ref of user who last updated the user.
		UpdatedBy *openapi_types.UUID `json:"updated_by"`

		// Username The username of the user.
		Username *string `json:"username"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAccountUserRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountUserRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]LabApp
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *LabApp
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *LabApp
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageAssessmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]struct {
		// Account The UUID ref of the group this assessment belongs to.
		Account *openapi_types.UUID `json:"account"`

		// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
		AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

		// AdjustedScore The score for the user-edited assessment report.
		AdjustedScore *float32 `json:"adjusted_score"`

		// Application The UUID ref of the application this assessment belongs to.
		Application *openapi_types.UUID `json:"application"`

		// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
		AppstoreDownload *GetAppPlatformPackageAssessment2XXAppstoreDownload `json:"appstore_download,omitempty"`

		// Binary The SHA-256 hash of the binary this assessment was run on.
		Binary *string `json:"binary"`

		// Cancelled Whether this assessment was manually cancelled before completion.
		Cancelled bool `json:"cancelled"`

		// Config The complete configuration this assessment was ran with.
		Config struct {
			// Dynamic The dynamic-specific configuration this assessment was ran with.
			Dynamic interface{} `json:"dynamic"`

			// Static The static-specific configuration this assessment was ran with.
			Static interface{} `json:"static"`
		} `json:"config"`

		// Created The date-time this assessment was created.
		Created *time.Time `json:"created"`

		// Creator The UUID ref of the user who triggered this assessment.
		Creator *openapi_types.UUID `json:"creator"`
		Events  struct {
			Dynamic []interface{} `json:"dynamic"`
		} `json:"events"`

		// Favorite Whether this assessment has been marked as a favorite.
		Favorite *bool `json:"favorite"`

		// Group The UUID ref of the group this assessment belongs to.
		Group *openapi_types.UUID `json:"group"`

		// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
		IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

		// Package The package ID of the application this assessment belongs to.
		Package string `json:"package"`

		// Platform The operating system of the application this assessment belongs to (android or ios).
		Platform string `json:"platform"`

		// Ref The unique identifier for the assessment.
		Ref openapi_types.UUID `json:"ref"`

		// Status An object describing the status of the static and dynamic tasks associated with this assessment.
		Status struct {
			// Dynamic A string describing the status of the dynamic task associated with this assessment.
			Dynamic interface{} `json:"dynamic"`

			// Static A string describing the status of the static task associated with this assessment.
			Static interface{} `json:"static"`
		} `json:"status"`

		// Task An integer identifying the underlying analysis tasks associated with this assessment.
		Task float32 `json:"task"`

		// TaskErrorCode The error code describing the failure if an assessment failed.
		TaskErrorCode *string `json:"task_error_code"`

		// TaskStatus The state of the assessment.
		TaskStatus *GetAppPlatformPackageAssessment2XXTaskStatus `json:"task_status,omitempty"`

		// Updated The date-time this assessment was last updated.
		Updated *time.Time `json:"updated"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type GetAppPlatformPackageAssessment2XXAppstoreDownload string
type GetAppPlatformPackageAssessment2XXTaskStatus string

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageAssessmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageAssessmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppPlatformPackageAssessmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Account The UUID ref of the group this assessment belongs to.
		Account *openapi_types.UUID `json:"account"`

		// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
		AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

		// AdjustedScore The score for the user-edited assessment report.
		AdjustedScore *float32 `json:"adjusted_score"`

		// Application The UUID ref of the application this assessment belongs to.
		Application *openapi_types.UUID `json:"application"`

		// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
		AppstoreDownload *PostAppPlatformPackageAssessment2XXAppstoreDownload `json:"appstore_download,omitempty"`

		// Binary The SHA-256 hash of the binary this assessment was run on.
		Binary *string `json:"binary"`

		// Cancelled Whether this assessment was manually cancelled before completion.
		Cancelled bool `json:"cancelled"`

		// Config The complete configuration this assessment was ran with.
		Config struct {
			// Dynamic The dynamic-specific configuration this assessment was ran with.
			Dynamic interface{} `json:"dynamic"`

			// Static The static-specific configuration this assessment was ran with.
			Static interface{} `json:"static"`
		} `json:"config"`

		// Created The date-time this assessment was created.
		Created *time.Time `json:"created"`

		// Creator The UUID ref of the user who triggered this assessment.
		Creator *openapi_types.UUID `json:"creator"`
		Events  struct {
			Dynamic []interface{} `json:"dynamic"`
		} `json:"events"`

		// Favorite Whether this assessment has been marked as a favorite.
		Favorite *bool `json:"favorite"`

		// Group The UUID ref of the group this assessment belongs to.
		Group *openapi_types.UUID `json:"group"`

		// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
		IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

		// Package The package ID of the application this assessment belongs to.
		Package string `json:"package"`

		// Platform The operating system of the application this assessment belongs to (android or ios).
		Platform string `json:"platform"`

		// Ref The unique identifier for the assessment.
		Ref openapi_types.UUID `json:"ref"`

		// Status An object describing the status of the static and dynamic tasks associated with this assessment.
		Status struct {
			// Dynamic A string describing the status of the dynamic task associated with this assessment.
			Dynamic interface{} `json:"dynamic"`

			// Static A string describing the status of the static task associated with this assessment.
			Static interface{} `json:"static"`
		} `json:"status"`

		// Task An integer identifying the underlying analysis tasks associated with this assessment.
		Task float64 `json:"task"`

		// TaskErrorCode The error code describing the failure if an assessment failed.
		TaskErrorCode *string `json:"task_error_code"`

		// TaskStatus The state of the assessment.
		TaskStatus *PostAppPlatformPackageAssessment2XXTaskStatus `json:"task_status,omitempty"`

		// Updated The date-time this assessment was last updated.
		Updated *time.Time `json:"updated"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type PostAppPlatformPackageAssessment2XXAppstoreDownload string
type PostAppPlatformPackageAssessment2XXTaskStatus string

// Status returns HTTPResponse.Status
func (r PostAppPlatformPackageAssessmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppPlatformPackageAssessmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageAssessmentTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Account The UUID ref of the group this assessment belongs to.
		Account *openapi_types.UUID `json:"account"`

		// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
		AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

		// AdjustedScore The score for the user-edited assessment report.
		AdjustedScore *float32 `json:"adjusted_score"`

		// Application The UUID ref of the application this assessment belongs to.
		Application *openapi_types.UUID `json:"application"`

		// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
		AppstoreDownload *GetAppPlatformPackageAssessmentTask2XXAppstoreDownload `json:"appstore_download,omitempty"`

		// Binary The SHA-256 hash of the binary this assessment was run on.
		Binary *string `json:"binary"`

		// Cancelled Whether this assessment was manually cancelled before completion.
		Cancelled bool `json:"cancelled"`

		// Config The complete configuration this assessment was ran with.
		Config struct {
			// Dynamic The dynamic-specific configuration this assessment was ran with.
			Dynamic interface{} `json:"dynamic"`

			// Static The static-specific configuration this assessment was ran with.
			Static interface{} `json:"static"`
		} `json:"config"`

		// Created The date-time this assessment was created.
		Created *time.Time `json:"created"`

		// Creator The UUID ref of the user who triggered this assessment.
		Creator *openapi_types.UUID `json:"creator"`
		Events  struct {
			Dynamic []interface{} `json:"dynamic"`
		} `json:"events"`

		// Favorite Whether this assessment has been marked as a favorite.
		Favorite *bool `json:"favorite"`

		// Group The UUID ref of the group this assessment belongs to.
		Group *openapi_types.UUID `json:"group"`

		// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
		IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

		// Package The package ID of the application this assessment belongs to.
		Package string `json:"package"`

		// Platform The operating system of the application this assessment belongs to (android or ios).
		Platform string `json:"platform"`

		// Ref The unique identifier for the assessment.
		Ref openapi_types.UUID `json:"ref"`

		// Status An object describing the status of the static and dynamic tasks associated with this assessment.
		Status struct {
			// Dynamic A string describing the status of the dynamic task associated with this assessment.
			Dynamic interface{} `json:"dynamic"`

			// Static A string describing the status of the static task associated with this assessment.
			Static interface{} `json:"static"`
		} `json:"status"`

		// Task An integer identifying the underlying analysis tasks associated with this assessment.
		Task float32 `json:"task"`

		// TaskErrorCode The error code describing the failure if an assessment failed.
		TaskErrorCode *string `json:"task_error_code"`

		// TaskStatus The state of the assessment.
		TaskStatus *GetAppPlatformPackageAssessmentTask2XXTaskStatus `json:"task_status,omitempty"`

		// Updated The date-time this assessment was last updated.
		Updated *time.Time `json:"updated"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type GetAppPlatformPackageAssessmentTask2XXAppstoreDownload string
type GetAppPlatformPackageAssessmentTask2XXTaskStatus string

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageAssessmentTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageAssessmentTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageAssessmentTaskRawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Dynamic The raw dynamic analysis results for the assessment.
		Dynamic *map[string]interface{} `json:"dynamic,omitempty"`

		// Static The raw static analysis results for the assessment.
		Static *map[string]interface{} `json:"static,omitempty"`

		// Yaap The raw YaapStatic analysis results for the assessment.
		Yaap *map[string]interface{} `json:"yaap,omitempty"`

		// YaapFiltered The raw YaapFilter analysis results for the assessment.
		YaapFiltered *map[string]interface{} `json:"yaap_filtered,omitempty"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageAssessmentTaskRawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageAssessmentTaskRawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppPlatformPackageAssessmentTaskCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Status The state of the assessment.
		Status PostAppPlatformPackageAssessmentTaskCancel2XXStatus `json:"status"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type PostAppPlatformPackageAssessmentTaskCancel2XXStatus string

// Status returns HTTPResponse.Status
func (r PostAppPlatformPackageAssessmentTaskCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppPlatformPackageAssessmentTaskCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageAssessmentTaskReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Dynamic The raw dynamic analysis results for the assessment.
		Dynamic *map[string]interface{} `json:"dynamic,omitempty"`

		// Static The raw static analysis results for the assessment.
		Static *map[string]interface{} `json:"static,omitempty"`

		// Yaap The raw YaapStatic analysis results for the assessment.
		Yaap *map[string]interface{} `json:"yaap,omitempty"`

		// YaapFiltered The raw YaapFilter analysis results for the assessment.
		YaapFiltered *map[string]interface{} `json:"yaap_filtered,omitempty"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageAssessmentTaskReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageAssessmentTaskReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageAssessmentTaskResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		union json.RawMessage
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type GetAppPlatformPackageAssessmentTaskResults2XX0 = []GetAppPlatformPackageAssessmentTaskResults_2XX_0_Item
type GetAppPlatformPackageAssessmentTaskResults_2XX_0_Issue struct {
	// Category The categorization of the finding.
	Category *string `json:"category,omitempty"`

	// Cvss The CVSS score of the finding.
	Cvss *float32 `json:"cvss,omitempty"`

	// CvssVector The CVSS vector of the finding.
	CvssVector *string `json:"cvss_vector,omitempty"`

	// Description The description of the finding issue.
	Description string `json:"description"`

	// ImpactSummary The description characterizing the general impact the vulnerability could have in the wild.
	ImpactSummary *string `json:"impact_summary,omitempty"`

	// PassContent The Markdown content relevant when the application is not found to be affected by the issue.
	PassContent *string `json:"pass_content,omitempty"`

	// Recommendation The remediation recommendation for the finding.
	Recommendation *string `json:"recommendation,omitempty"`

	// Severity The severity of the finding.
	Severity string `json:"severity"`

	// StepsToReproduce The steps to reproduce the finding.
	StepsToReproduce *string `json:"steps_to_reproduce,omitempty"`

	// Title The title of the finding issue.
	Title                string                 `json:"title"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetAppPlatformPackageAssessmentTaskResults2XX0Kind string
type GetAppPlatformPackageAssessmentTaskResults_2XX_0_Item struct {
	// Affected Determines if finding is affected in the assessment in which it was found.
	Affected bool `json:"affected"`

	// Category The categorization of the finding.
	Category *string `json:"category,omitempty"`

	// Context The context or evidence related to the finding.
	Context *struct {
		Certificate *map[string]interface{}            `json:"certificate,omitempty"`
		Fields      *map[string]map[string]interface{} `json:"fields,omitempty"`
		PdfView     *string                            `json:"pdfView,omitempty"`
		Rows        *map[string]interface{}            `json:"rows,omitempty"`
	} `json:"context,omitempty"`

	// Cvss The CVSS score of the finding.
	Cvss *float32 `json:"cvss,omitempty"`

	// CvssVector The CVSS vector of the finding.
	CvssVector *string `json:"cvss_vector,omitempty"`

	// Description The Markdown content describing the finding in more detail.
	Description *string                                                 `json:"description,omitempty"`
	Issue       *GetAppPlatformPackageAssessmentTaskResults_2XX_0_Issue `json:"issue,omitempty"`

	// Kind The specific analysis type associated with the finding.
	Kind GetAppPlatformPackageAssessmentTaskResults2XX0Kind `json:"kind"`

	// Recommendation The remediation recommendation for the finding.
	Recommendation *string `json:"recommendation"`

	// Regulatory The regulatory links for the finding.
	Regulatory map[string][]struct {
		Id      string  `json:"id"`
		Url     *string `json:"url,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"regulatory"`

	// Severity The severity of the finding.
	Severity string `json:"severity"`

	// Summary The summary description of the finding.
	Summary *string `json:"summary"`

	// Title The title of the finding.
	Title                string                 `json:"title"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetAppPlatformPackageAssessmentTaskResults2XX1 = []GetAppPlatformPackageAssessmentTaskResults_2XX_1_Item
type GetAppPlatformPackageAssessmentTaskResults2XX1Kind string
type GetAppPlatformPackageAssessmentTaskResults_2XX_1_Item struct {
	// Affected Determines if finding is affected in the assessment in which it was found.
	Affected bool `json:"affected"`

	// Category The categorization of the finding.
	Category *string `json:"category,omitempty"`

	// Description The Markdown content describing the finding in more detail.
	Description *string `json:"description,omitempty"`

	// Kind The specific analysis type associated with the finding.
	Kind GetAppPlatformPackageAssessmentTaskResults2XX1Kind `json:"kind"`

	// Recommendation The remediation recommendation for the finding.
	Recommendation *string `json:"recommendation"`

	// Regulatory The regulatory links for the finding.
	Regulatory map[string][]struct {
		Id      string  `json:"id"`
		Url     *string `json:"url,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"regulatory"`

	// Severity The severity of the finding.
	Severity *string `json:"severity,omitempty"`

	// Summary The Markdown content describing the finding in more detail.
	Summary *string `json:"summary,omitempty"`

	// Title The title of the finding.
	Title                string                 `json:"title"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageAssessmentTaskResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageAssessmentTaskResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppPlatformPackageBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Account Deprecated. Use group instead.
		Account openapi_types.UUID `json:"account"`

		// Analyzed True if the last analysis of this application has completed.
		Analyzed *bool `json:"analyzed,omitempty"`

		// Application The UUID ref of the application the build belongs to.
		Application openapi_types.UUID `json:"application"`

		// Created Creation date of the application record.
		Created time.Time `json:"created"`

		// Digest The SHA-256 digest of the analyzed binary. Note that some applications are repackaged prior to analysis, so this digest may differ from the digest of the uploaded file.
		Digest string `json:"digest"`

		// DownloadedAppstoreApplicationKey The App store / Play store key for applications downloaded from a store.
		DownloadedAppstoreApplicationKey *string `json:"downloaded_appstore_application_key,omitempty"`

		// Group The UUID identifier of the group this application belongs to.
		Group openapi_types.UUID `json:"group"`

		// Icon The icon of the application in base64 format.
		Icon *string `json:"icon,omitempty"`

		// Package The package or bundle ID.
		Package string `json:"package"`

		// Platform The operating system of the application (android or ios).
		Platform *string `json:"platform,omitempty"`

		// Ref The UUID identifier of the application binary.
		Ref openapi_types.UUID `json:"ref"`

		// Title The application title.
		Title *string `json:"title,omitempty"`

		// Uploaded The date-time the binary was uploaded.
		Uploaded *string `json:"uploaded,omitempty"`

		// Uploader The UUID identifier of the user who uploaded the application.
		Uploader *string `json:"uploader,omitempty"`

		// Version The application version string.
		Version *string `json:"version,omitempty"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostAppPlatformPackageBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppPlatformPackageBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *AppBuildList
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppPlatformPackageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Dynamic The dynamic configuration for the application.
		Dynamic      *map[string]interface{} `json:"dynamic,omitempty"`
		Integrations *struct {
			PENTEST *struct {
				Azure *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						ReferenceName string `json:"referenceName"`
						Type          string `json:"type"`
						Value         string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					OrganizationName     string                  `json:"organizationName"`
					ProjectId            string                  `json:"projectId"`
					Tags                 *[]string               `json:"tags,omitempty"`
					WorkItemType         string                  `json:"workItemType"`
				} `json:"azure,omitempty"`
				Github *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					Labels                    *[]string `json:"labels,omitempty"`
					Repository                string    `json:"repository"`
				} `json:"github,omitempty"`
				Gitlab *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
					GroupId                   string    `json:"groupId"`
					Labels                    *[]string `json:"labels,omitempty"`
					ProjectId                 string    `json:"projectId"`
				} `json:"gitlab,omitempty"`
				Jira *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					BaseUrl                   *string `json:"baseUrl,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						Name  string `json:"name"`
						Type  string `json:"type"`
						Value string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					IssueType            *string                 `json:"issueType,omitempty"`
					Labels               *[]string               `json:"labels,omitempty"`
					Project              string                  `json:"project"`
				} `json:"jira,omitempty"`
				Servicenow *struct {
					AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
					AutomationRules      struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CategorySysId             *string `json:"categorySysId,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
					ImpactLevel               *string `json:"impactLevel,omitempty"`
					UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
				} `json:"servicenow,omitempty"`
			} `json:"PEN_TEST,omitempty"`
			PLATFORM *struct {
				Azure *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						ReferenceName string `json:"referenceName"`
						Type          string `json:"type"`
						Value         string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					OrganizationName     string                  `json:"organizationName"`
					ProjectId            string                  `json:"projectId"`
					Tags                 *[]string               `json:"tags,omitempty"`
					WorkItemType         string                  `json:"workItemType"`
				} `json:"azure,omitempty"`
				Github *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					Labels                    *[]string `json:"labels,omitempty"`
					Repository                string    `json:"repository"`
				} `json:"github,omitempty"`
				Gitlab *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
					GroupId                   string    `json:"groupId"`
					Labels                    *[]string `json:"labels,omitempty"`
					ProjectId                 string    `json:"projectId"`
				} `json:"gitlab,omitempty"`
				Jira *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					BaseUrl                   *string `json:"baseUrl,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						Name  string `json:"name"`
						Type  string `json:"type"`
						Value string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					IssueType            *string                 `json:"issueType,omitempty"`
					Labels               *[]string               `json:"labels,omitempty"`
					Project              string                  `json:"project"`
				} `json:"jira,omitempty"`
				Servicenow *struct {
					AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
					AutomationRules      struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CategorySysId             *string `json:"categorySysId,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
					ImpactLevel               *string `json:"impactLevel,omitempty"`
					UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
				} `json:"servicenow,omitempty"`
			} `json:"PLATFORM,omitempty"`
		} `json:"integrations,omitempty"`

		// Static The static configuration for the application.
		Static *map[string]interface{} `json:"static,omitempty"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAppPlatformPackageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppPlatformPackageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppPlatformPackageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Dynamic The dynamic configuration for the application.
		Dynamic      *map[string]interface{} `json:"dynamic,omitempty"`
		Integrations *struct {
			PENTEST *struct {
				Azure *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						ReferenceName string `json:"referenceName"`
						Type          string `json:"type"`
						Value         string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					OrganizationName     string                  `json:"organizationName"`
					ProjectId            string                  `json:"projectId"`
					Tags                 *[]string               `json:"tags,omitempty"`
					WorkItemType         string                  `json:"workItemType"`
				} `json:"azure,omitempty"`
				Github *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					Labels                    *[]string `json:"labels,omitempty"`
					Repository                string    `json:"repository"`
				} `json:"github,omitempty"`
				Gitlab *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
					GroupId                   string    `json:"groupId"`
					Labels                    *[]string `json:"labels,omitempty"`
					ProjectId                 string    `json:"projectId"`
				} `json:"gitlab,omitempty"`
				Jira *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					BaseUrl                   *string `json:"baseUrl,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						Name  string `json:"name"`
						Type  string `json:"type"`
						Value string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					IssueType            *string                 `json:"issueType,omitempty"`
					Labels               *[]string               `json:"labels,omitempty"`
					Project              string                  `json:"project"`
				} `json:"jira,omitempty"`
				Servicenow *struct {
					AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
					AutomationRules      struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CategorySysId             *string `json:"categorySysId,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
					ImpactLevel               *string `json:"impactLevel,omitempty"`
					UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
				} `json:"servicenow,omitempty"`
			} `json:"PEN_TEST,omitempty"`
			PLATFORM *struct {
				Azure *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						ReferenceName string `json:"referenceName"`
						Type          string `json:"type"`
						Value         string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					OrganizationName     string                  `json:"organizationName"`
					ProjectId            string                  `json:"projectId"`
					Tags                 *[]string               `json:"tags,omitempty"`
					WorkItemType         string                  `json:"workItemType"`
				} `json:"azure,omitempty"`
				Github *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					Labels                    *[]string `json:"labels,omitempty"`
					Repository                string    `json:"repository"`
				} `json:"github,omitempty"`
				Gitlab *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
					GroupId                   string    `json:"groupId"`
					Labels                    *[]string `json:"labels,omitempty"`
					ProjectId                 string    `json:"projectId"`
				} `json:"gitlab,omitempty"`
				Jira *struct {
					AutomationRules struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					BaseUrl                   *string `json:"baseUrl,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					CustomFields              *[]struct {
						Name  string `json:"name"`
						Type  string `json:"type"`
						Value string `json:"value"`
					} `json:"customFields,omitempty"`
					ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
					IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
					IssueType            *string                 `json:"issueType,omitempty"`
					Labels               *[]string               `json:"labels,omitempty"`
					Project              string                  `json:"project"`
				} `json:"jira,omitempty"`
				Servicenow *struct {
					AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
					AutomationRules      struct {
						PolicyCategories *struct {
							Category1 bool `json:"category1"`
							Category2 bool `json:"category2"`
							Category3 bool `json:"category3"`
						} `json:"policyCategories,omitempty"`
						Severities *struct {
							Critical bool `json:"critical"`
							High     bool `json:"high"`
							Info     bool `json:"info"`
							Low      bool `json:"low"`
							Medium   bool `json:"medium"`
							Warn     bool `json:"warn"`
						} `json:"severities,omitempty"`
					} `json:"automationRules"`
					CategorySysId             *string `json:"categorySysId,omitempty"`
					CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
					ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
					ImpactLevel               *string `json:"impactLevel,omitempty"`
					UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
				} `json:"servicenow,omitempty"`
			} `json:"PLATFORM,omitempty"`
		} `json:"integrations,omitempty"`

		// Static The static configuration for the application.
		Static *map[string]interface{} `json:"static,omitempty"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostAppPlatformPackageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppPlatformPackageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppPlatformPackageRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *LabApp
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r DeleteAppPlatformPackageRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppPlatformPackageRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppPlatformPackageRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *LabApp
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostAppPlatformPackageRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppPlatformPackageRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssessmentRefReportHtmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAssessmentRefReportHtmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssessmentRefReportHtmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssessmentRefReportJsonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAssessmentRefReportJsonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssessmentRefReportJsonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssessmentRefReportPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetAssessmentRefReportPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssessmentRefReportPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssessmentTaskFindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]GetAssessmentTaskFindings_2XX_Item
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}
type GetAssessmentTaskFindings2XXAnalysisType string
type GetAssessmentTaskFindings_2XX_Item struct {
	// Affected Determines if finding is affected in the assessment in which it was found.
	Affected bool `json:"affected"`

	// AnalysisType The specific analysis type associated with the finding.
	AnalysisType GetAssessmentTaskFindings2XXAnalysisType `json:"analysis_type"`

	// Category The categorization of the finding.
	Category *string `json:"category,omitempty"`

	// Changes The list of user changes made to the finding.
	Changes *[]struct {
		Date time.Time `json:"date"`
		User struct {
			Name string             `json:"name"`
			Ref  openapi_types.UUID `json:"ref"`
		} `json:"user"`
	} `json:"changes"`

	// CheckId The finding check ID.
	CheckId string `json:"check_id"`

	// Context The context or evidence related to the finding.
	Context *struct {
		Certificate *map[string]interface{}            `json:"certificate,omitempty"`
		Fields      *map[string]map[string]interface{} `json:"fields,omitempty"`
		PdfView     *string                            `json:"pdfView,omitempty"`
		Rows        *map[string]interface{}            `json:"rows,omitempty"`
	} `json:"context,omitempty"`

	// Cvss The CVSS score of the finding.
	Cvss *float32 `json:"cvss,omitempty"`

	// CvssVector The CVSS vector of the finding.
	CvssVector *string `json:"cvss_vector,omitempty"`

	// Description The Markdown content describing the finding in more detail.
	Description *string `json:"description,omitempty"`

	// Hidden Determines if the finding should be shown in a report.
	Hidden bool `json:"hidden"`

	// Recommendations The object detailing remdediation recommendations for the finding.
	Recommendations struct {
		Developer *string `json:"developer,omitempty"`
	} `json:"recommendations"`

	// Regulations The regulatory links for the finding.
	Regulations *[]struct {
		Links []struct {
			Id  string  `json:"id"`
			Url *string `json:"url,omitempty"`
		} `json:"links"`
		Type string `json:"type"`
	} `json:"regulations,omitempty"`

	// Severity The severity of the finding.
	Severity string `json:"severity"`

	// Title The title of the finding.
	Title string `json:"title"`

	// UniqueVulnerabilityId The unique integer vulnerability ID associated with the finding, if vulnerable.
	UniqueVulnerabilityId *int `json:"unique_vulnerability_id,omitempty"`

	// VulnerabilityDetail The description of the vulnerability.
	VulnerabilityDetail *string `json:"vulnerability_detail,omitempty"`

	// VulnerabilityTitl The title of the vulnerability.
	VulnerabilityTitl    *string                `json:"vulnerability_titl,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetAssessmentTaskFindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssessmentTaskFindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssessmentTaskSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
		AdjustedIssues interface{} `json:"adjusted_issues"`

		// BaseScore The score for the unedited assessment report.
		BaseScore *float32 `json:"base_score"`

		// Changes An object associating user-made overrides to findings by their key.
		Changes     interface{}                             `json:"changes"`
		CvssVersion *GetAssessmentTaskSummary2XXCvssVersion `json:"cvss_version"`

		// FindingsDigest A digest identifying the findings version used for this assessment report.
		FindingsDigest *string `json:"findings_digest"`

		// Issues A map from finding keys to the finding's associated CVSS score in the unedited assessment report.
		Issues interface{} `json:"issues"`

		// Score The score for the user-edited assessment report.
		Score *float32 `json:"score"`

		// Status The state of the assessment.
		Status GetAssessmentTaskSummary2XXStatus `json:"status"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type GetAssessmentTaskSummary2XXCvssVersion string
type GetAssessmentTaskSummary2XXStatus string

// Status returns HTTPResponse.Status
func (r GetAssessmentTaskSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssessmentTaskSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Algorithm The hashing algorithm used to generate the binary digest.
		Algorithm *string `json:"algorithm"`

		// Analyzed Whether the binary has been analyzed.
		Analyzed *bool `json:"analyzed"`

		// Digest The hash digest of the binary file.
		Digest string `json:"digest"`

		// DownloadedAppstoreApplicationKey The iOS application store ID or Android package name for the app binary as it exists in the app store.
		DownloadedAppstoreApplicationKey *string `json:"downloaded_appstore_application_key"`

		// Icon The Base64 encoded string for the binary's icon.
		Icon *string `json:"icon"`

		// Name The name of the application the binary is for.
		Name *string `json:"name"`

		// Package The iOS Bundle ID or Android package name for the binary.
		Package *string `json:"package"`

		// Platform The Platform (ios/android) of the binary.
		Platform *string `json:"platform"`

		// Title The title of the application the binary is for.
		Title *string `json:"title"`
		Token *string `json:"token"`

		// UploadRef The unique identifier for the upload record associated with this binary.
		UploadRef *openapi_types.UUID `json:"uploadRef,omitempty"`

		// Version The application version of the binary.
		Version *string `json:"version"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinaryDigestAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]GetBinaryDigestAnalysis_2XX_Item
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}
type GetBinaryDigestAnalysis2XX0 struct {
	// Digest The SHA-256 digest of the binary preflight is being run on.
	Digest *string `json:"digest,omitempty"`

	// Group The UUID group ref of the binary preflight is being run on.
	Group *openapi_types.UUID `json:"group,omitempty"`

	// Message An additional explanatory message for the status update.
	Message *string `json:"message,omitempty"`

	// Status The status of preflight analysis.
	Status GetBinaryDigestAnalysis_2XX_0_Status `json:"status"`

	// WorkflowRequestId A unique integer identifier for the preflight analysis.
	WorkflowRequestId    *float32               `json:"workflow_request_id,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetBinaryDigestAnalysis2XX0Status0 string
type GetBinaryDigestAnalysis2XX0Status1 string
type GetBinaryDigestAnalysis2XX0Status2 string
type GetBinaryDigestAnalysis2XX0Status3 string
type GetBinaryDigestAnalysis2XX0Status4 string
type GetBinaryDigestAnalysis_2XX_0_Status struct {
	union json.RawMessage
}
type GetBinaryDigestAnalysis2XX1 struct {
	// Error A message describing the error that occurred.
	Error  string                            `json:"error"`
	Status GetBinaryDigestAnalysis2XX1Status `json:"status"`

	// WorkflowRequestId A unique integer identifier for the preflight analysis.
	WorkflowRequestId    *float32               `json:"workflow_request_id,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetBinaryDigestAnalysis2XX1Status string
type GetBinaryDigestAnalysis_2XX_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetBinaryDigestAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinaryDigestAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *AppBuildList
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r GetBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		union json.RawMessage
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}
type PostBuild2XX0 struct {
	// Binary The SHA-256 hash of the analyzed binary.
	Binary string `json:"binary"`

	// Group The UUID ref of the group this application belongs to.
	Group string `json:"group"`

	// Package The package ID of the application.
	Package string `json:"package"`

	// Platform The operating system of the application (android or ios).
	Platform string `json:"platform"`

	// Version The application version.
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type PostBuild2XX1 struct {
	// Account The UUID ref of the group this assessment belongs to.
	Account *openapi_types.UUID `json:"account"`

	// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
	AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

	// AdjustedScore The score for the user-edited assessment report.
	AdjustedScore *float32 `json:"adjusted_score"`

	// Application The UUID ref of the application this assessment belongs to.
	Application *openapi_types.UUID `json:"application"`

	// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
	AppstoreDownload *PostBuild2XX1AppstoreDownload `json:"appstore_download,omitempty"`

	// Binary The SHA-256 hash of the binary this assessment was run on.
	Binary *string `json:"binary"`

	// Cancelled Whether this assessment was manually cancelled before completion.
	Cancelled bool `json:"cancelled"`

	// Config The complete configuration this assessment was ran with.
	Config struct {
		// Dynamic The dynamic-specific configuration this assessment was ran with.
		Dynamic interface{} `json:"dynamic"`

		// Static The static-specific configuration this assessment was ran with.
		Static interface{} `json:"static"`
	} `json:"config"`

	// Created The date-time this assessment was created.
	Created *time.Time `json:"created"`

	// Creator The UUID ref of the user who triggered this assessment.
	Creator *openapi_types.UUID `json:"creator"`
	Events  struct {
		Dynamic []interface{} `json:"dynamic"`
	} `json:"events"`

	// Favorite Whether this assessment has been marked as a favorite.
	Favorite *bool `json:"favorite"`

	// Group The UUID ref of the group this assessment belongs to.
	Group *openapi_types.UUID `json:"group"`

	// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
	IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

	// Package The package ID of the application this assessment belongs to.
	Package string `json:"package"`

	// Platform The operating system of the application this assessment belongs to (android or ios).
	Platform string `json:"platform"`

	// Ref The unique identifier for the assessment.
	Ref openapi_types.UUID `json:"ref"`

	// Status An object describing the status of the static and dynamic tasks associated with this assessment.
	Status struct {
		// Dynamic A string describing the status of the dynamic task associated with this assessment.
		Dynamic interface{} `json:"dynamic"`

		// Static A string describing the status of the static task associated with this assessment.
		Static interface{} `json:"static"`
	} `json:"status"`

	// Task An integer identifying the underlying analysis tasks associated with this assessment.
	// TODO: Comment on upstream issue on float64 defaults
	Task float64 `json:"task"`

	// TaskErrorCode The error code describing the failure if an assessment failed.
	TaskErrorCode *string `json:"task_error_code"`

	// TaskStatus The state of the assessment.
	TaskStatus *PostBuild2XX1TaskStatus `json:"task_status,omitempty"`

	// Updated The date-time this assessment was last updated.
	Updated *time.Time `json:"updated"`
}
type PostBuild2XX1AppstoreDownload string
type PostBuild2XX1TaskStatus string

// Status returns HTTPResponse.Status
func (r PostBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBuildPlatformPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Binary The SHA-256 digest of the analyzed binary. Note that some applications are repackaged prior to analysis, so this digest may differ from the digest of the uploaded file.
		Binary string `json:"binary"`

		// Group The UUID identifier of the group this application belongs to.
		Group openapi_types.UUID `json:"group"`

		// Package The package or bundle ID.
		Package string `json:"package"`

		// Platform The operating system of the application (android or ios).
		Platform *string `json:"platform,omitempty"`

		// Version The application version string.
		Version              *string                `json:"version,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	JSON4XX *LabRouteError
	JSON5XX *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostBuildPlatformPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBuildPlatformPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLoginTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *ActionResult
	JSON4XX      *StandardError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostLoginTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLoginTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabApp
	JSON4XX      *LabRouteError
	JSON5XX      *LabRouteError
}

// Status returns HTTPResponse.Status
func (r PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]struct {
		// Exp Expires at
		Exp *float32 `json:"exp,omitempty"`

		// Iat Issued at
		Iat *float32 `json:"iat,omitempty"`

		// Iss Issuer
		Iss string `json:"iss"`

		// Jti jti/ref
		Jti openapi_types.UUID `json:"jti"`

		// Name Name
		Name *string `json:"name,omitempty"`

		// Sub User ref
		Sub openapi_types.UUID `json:"sub"`
	}
	JSON4XX *StandardError
	JSON5XX *StandardError
}

// Status returns HTTPResponse.Status
func (r GetUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Data struct {
			// Exp Expires at
			Exp float32 `json:"exp"`

			// Iat Issued at
			Iat float32 `json:"iat"`

			// Iss Issuer
			Iss string `json:"iss"`

			// Jti jti/ref
			Jti openapi_types.UUID `json:"jti"`

			// Name Name
			Name string `json:"name"`

			// Sub User ref
			Sub openapi_types.UUID `json:"sub"`
		} `json:"data"`
		Token string `json:"token"`
	}
	JSON4XX *StandardError
	JSON5XX *StandardError
}

// Status returns HTTPResponse.Status
func (r PostUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserTokenRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Data struct {
			// Exp Expires at
			Exp float32 `json:"exp"`

			// Iat Issued at
			Iat float32 `json:"iat"`

			// Iss Issuer
			Iss string `json:"iss"`

			// Jti jti/ref
			Jti openapi_types.UUID `json:"jti"`

			// Name Name
			Name string `json:"name"`

			// Sub User ref
			Sub openapi_types.UUID `json:"sub"`
		} `json:"data"`
		Token string `json:"token"`
	}
	JSON404 *struct {
		Message string `json:"message"`
		Name    string `json:"name"`
	}
	JSON4XX *StandardError
	JSON5XX *StandardError
}

// Status returns HTTPResponse.Status
func (r PostUserTokenRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserTokenRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountUserWithResponse request returning *GetAccountUserResponse
func (c *ClientWithResponses) GetAccountUserWithResponse(ctx context.Context, params *GetAccountUserParams, reqEditors ...RequestEditorFn) (*GetAccountUserResponse, error) {
	rsp, err := c.GetAccountUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountUserResponse(rsp)
}

// GetAccountUserRefWithResponse request returning *GetAccountUserRefResponse
func (c *ClientWithResponses) GetAccountUserRefWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAccountUserRefResponse, error) {
	rsp, err := c.GetAccountUserRef(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountUserRefResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// PostAppWithBodyWithResponse request with arbitrary body returning *PostAppResponse
func (c *ClientWithResponses) PostAppWithBodyWithResponse(ctx context.Context, params *PostAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppResponse, error) {
	rsp, err := c.PostAppWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppResponse(rsp)
}

func (c *ClientWithResponses) PostAppWithResponse(ctx context.Context, params *PostAppParams, body PostAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppResponse, error) {
	rsp, err := c.PostApp(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppResponse(rsp)
}

// GetAppPlatformPackageWithResponse request returning *GetAppPlatformPackageResponse
func (c *ClientWithResponses) GetAppPlatformPackageWithResponse(ctx context.Context, platform GetAppPlatformPackageParamsPlatform, pPackage string, params *GetAppPlatformPackageParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageResponse, error) {
	rsp, err := c.GetAppPlatformPackage(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageResponse(rsp)
}

// GetAppPlatformPackageAssessmentWithResponse request returning *GetAppPlatformPackageAssessmentResponse
func (c *ClientWithResponses) GetAppPlatformPackageAssessmentWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *GetAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentResponse, error) {
	rsp, err := c.GetAppPlatformPackageAssessment(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageAssessmentResponse(rsp)
}

// PostAppPlatformPackageAssessmentWithResponse request returning *PostAppPlatformPackageAssessmentResponse
func (c *ClientWithResponses) PostAppPlatformPackageAssessmentWithResponse(ctx context.Context, platform PostAppPlatformPackageAssessmentParamsPlatform, pPackage string, params *PostAppPlatformPackageAssessmentParams, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageAssessmentResponse, error) {
	rsp, err := c.PostAppPlatformPackageAssessment(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageAssessmentResponse(rsp)
}

// GetAppPlatformPackageAssessmentTaskWithResponse request returning *GetAppPlatformPackageAssessmentTaskResponse
func (c *ClientWithResponses) GetAppPlatformPackageAssessmentTaskWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskResponse, error) {
	rsp, err := c.GetAppPlatformPackageAssessmentTask(ctx, platform, pPackage, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageAssessmentTaskResponse(rsp)
}

// GetAppPlatformPackageAssessmentTaskRawWithResponse request returning *GetAppPlatformPackageAssessmentTaskRawResponse
func (c *ClientWithResponses) GetAppPlatformPackageAssessmentTaskRawWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskRawParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskRawParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskRawResponse, error) {
	rsp, err := c.GetAppPlatformPackageAssessmentTaskRaw(ctx, platform, pPackage, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageAssessmentTaskRawResponse(rsp)
}

// PostAppPlatformPackageAssessmentTaskCancelWithResponse request returning *PostAppPlatformPackageAssessmentTaskCancelResponse
func (c *ClientWithResponses) PostAppPlatformPackageAssessmentTaskCancelWithResponse(ctx context.Context, platform PostAppPlatformPackageAssessmentTaskCancelParamsPlatform, pPackage string, task float32, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageAssessmentTaskCancelResponse, error) {
	rsp, err := c.PostAppPlatformPackageAssessmentTaskCancel(ctx, platform, pPackage, task, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageAssessmentTaskCancelResponse(rsp)
}

// GetAppPlatformPackageAssessmentTaskReportWithResponse request returning *GetAppPlatformPackageAssessmentTaskReportResponse
func (c *ClientWithResponses) GetAppPlatformPackageAssessmentTaskReportWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskReportParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskReportParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskReportResponse, error) {
	rsp, err := c.GetAppPlatformPackageAssessmentTaskReport(ctx, platform, pPackage, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageAssessmentTaskReportResponse(rsp)
}

// GetAppPlatformPackageAssessmentTaskResultsWithResponse request returning *GetAppPlatformPackageAssessmentTaskResultsResponse
func (c *ClientWithResponses) GetAppPlatformPackageAssessmentTaskResultsWithResponse(ctx context.Context, platform GetAppPlatformPackageAssessmentTaskResultsParamsPlatform, pPackage string, task int, params *GetAppPlatformPackageAssessmentTaskResultsParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageAssessmentTaskResultsResponse, error) {
	rsp, err := c.GetAppPlatformPackageAssessmentTaskResults(ctx, platform, pPackage, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageAssessmentTaskResultsResponse(rsp)
}

// PostAppPlatformPackageBinaryWithResponse request returning *PostAppPlatformPackageBinaryResponse
func (c *ClientWithResponses) PostAppPlatformPackageBinaryWithResponse(ctx context.Context, platform PostAppPlatformPackageBinaryParamsPlatform, pPackage string, params *PostAppPlatformPackageBinaryParams, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageBinaryResponse, error) {
	rsp, err := c.PostAppPlatformPackageBinary(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageBinaryResponse(rsp)
}

// GetAppPlatformPackageBuildWithResponse request returning *GetAppPlatformPackageBuildResponse
func (c *ClientWithResponses) GetAppPlatformPackageBuildWithResponse(ctx context.Context, platform GetAppPlatformPackageBuildParamsPlatform, pPackage string, params *GetAppPlatformPackageBuildParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageBuildResponse, error) {
	rsp, err := c.GetAppPlatformPackageBuild(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageBuildResponse(rsp)
}

// GetAppPlatformPackageConfigWithResponse request returning *GetAppPlatformPackageConfigResponse
func (c *ClientWithResponses) GetAppPlatformPackageConfigWithResponse(ctx context.Context, platform GetAppPlatformPackageConfigParamsPlatform, pPackage string, params *GetAppPlatformPackageConfigParams, reqEditors ...RequestEditorFn) (*GetAppPlatformPackageConfigResponse, error) {
	rsp, err := c.GetAppPlatformPackageConfig(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppPlatformPackageConfigResponse(rsp)
}

// PostAppPlatformPackageConfigWithBodyWithResponse request with arbitrary body returning *PostAppPlatformPackageConfigResponse
func (c *ClientWithResponses) PostAppPlatformPackageConfigWithBodyWithResponse(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageConfigResponse, error) {
	rsp, err := c.PostAppPlatformPackageConfigWithBody(ctx, platform, pPackage, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageConfigResponse(rsp)
}

func (c *ClientWithResponses) PostAppPlatformPackageConfigWithResponse(ctx context.Context, platform PostAppPlatformPackageConfigParamsPlatform, pPackage string, params *PostAppPlatformPackageConfigParams, body PostAppPlatformPackageConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageConfigResponse, error) {
	rsp, err := c.PostAppPlatformPackageConfig(ctx, platform, pPackage, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageConfigResponse(rsp)
}

// DeleteAppPlatformPackageRunnerWithResponse request returning *DeleteAppPlatformPackageRunnerResponse
func (c *ClientWithResponses) DeleteAppPlatformPackageRunnerWithResponse(ctx context.Context, platform DeleteAppPlatformPackageRunnerParamsPlatform, pPackage string, params *DeleteAppPlatformPackageRunnerParams, reqEditors ...RequestEditorFn) (*DeleteAppPlatformPackageRunnerResponse, error) {
	rsp, err := c.DeleteAppPlatformPackageRunner(ctx, platform, pPackage, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppPlatformPackageRunnerResponse(rsp)
}

// PostAppPlatformPackageRunnerWithBodyWithResponse request with arbitrary body returning *PostAppPlatformPackageRunnerResponse
func (c *ClientWithResponses) PostAppPlatformPackageRunnerWithBodyWithResponse(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageRunnerResponse, error) {
	rsp, err := c.PostAppPlatformPackageRunnerWithBody(ctx, platform, pPackage, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageRunnerResponse(rsp)
}

func (c *ClientWithResponses) PostAppPlatformPackageRunnerWithResponse(ctx context.Context, platform PostAppPlatformPackageRunnerParamsPlatform, pPackage string, params *PostAppPlatformPackageRunnerParams, body PostAppPlatformPackageRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppPlatformPackageRunnerResponse, error) {
	rsp, err := c.PostAppPlatformPackageRunner(ctx, platform, pPackage, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppPlatformPackageRunnerResponse(rsp)
}

// GetAssessmentRefReportHtmlWithResponse request returning *GetAssessmentRefReportHtmlResponse
func (c *ClientWithResponses) GetAssessmentRefReportHtmlWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssessmentRefReportHtmlResponse, error) {
	rsp, err := c.GetAssessmentRefReportHtml(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssessmentRefReportHtmlResponse(rsp)
}

// GetAssessmentRefReportJsonWithResponse request returning *GetAssessmentRefReportJsonResponse
func (c *ClientWithResponses) GetAssessmentRefReportJsonWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssessmentRefReportJsonResponse, error) {
	rsp, err := c.GetAssessmentRefReportJson(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssessmentRefReportJsonResponse(rsp)
}

// GetAssessmentRefReportPdfWithResponse request returning *GetAssessmentRefReportPdfResponse
func (c *ClientWithResponses) GetAssessmentRefReportPdfWithResponse(ctx context.Context, ref openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssessmentRefReportPdfResponse, error) {
	rsp, err := c.GetAssessmentRefReportPdf(ctx, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssessmentRefReportPdfResponse(rsp)
}

// GetAssessmentTaskFindingsWithResponse request returning *GetAssessmentTaskFindingsResponse
func (c *ClientWithResponses) GetAssessmentTaskFindingsWithResponse(ctx context.Context, task float32, params *GetAssessmentTaskFindingsParams, reqEditors ...RequestEditorFn) (*GetAssessmentTaskFindingsResponse, error) {
	rsp, err := c.GetAssessmentTaskFindings(ctx, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssessmentTaskFindingsResponse(rsp)
}

// GetAssessmentTaskSummaryWithResponse request returning *GetAssessmentTaskSummaryResponse
func (c *ClientWithResponses) GetAssessmentTaskSummaryWithResponse(ctx context.Context, task float32, params *GetAssessmentTaskSummaryParams, reqEditors ...RequestEditorFn) (*GetAssessmentTaskSummaryResponse, error) {
	rsp, err := c.GetAssessmentTaskSummary(ctx, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssessmentTaskSummaryResponse(rsp)
}

// PostBinaryWithBodyWithResponse request with arbitrary body returning *PostBinaryResponse
func (c *ClientWithResponses) PostBinaryWithBodyWithResponse(ctx context.Context, params *PostBinaryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBinaryResponse, error) {
	rsp, err := c.PostBinaryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBinaryResponse(rsp)
}

func (c *ClientWithResponses) PostBinaryWithResponse(ctx context.Context, params *PostBinaryParams, body PostBinaryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBinaryResponse, error) {
	rsp, err := c.PostBinary(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBinaryResponse(rsp)
}

// GetBinaryDigestAnalysisWithResponse request returning *GetBinaryDigestAnalysisResponse
func (c *ClientWithResponses) GetBinaryDigestAnalysisWithResponse(ctx context.Context, digest string, params *GetBinaryDigestAnalysisParams, reqEditors ...RequestEditorFn) (*GetBinaryDigestAnalysisResponse, error) {
	rsp, err := c.GetBinaryDigestAnalysis(ctx, digest, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinaryDigestAnalysisResponse(rsp)
}

// GetBuildWithResponse request returning *GetBuildResponse
func (c *ClientWithResponses) GetBuildWithResponse(ctx context.Context, params *GetBuildParams, reqEditors ...RequestEditorFn) (*GetBuildResponse, error) {
	rsp, err := c.GetBuild(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildResponse(rsp)
}

// PostBuildWithBodyWithResponse request with arbitrary body returning *PostBuildResponse
func (c *ClientWithResponses) PostBuildWithBodyWithResponse(ctx context.Context, params *PostBuildParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBuildResponse, error) {
	rsp, err := c.PostBuildWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBuildResponse(rsp)
}

func (c *ClientWithResponses) PostBuildWithResponse(ctx context.Context, params *PostBuildParams, body PostBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBuildResponse, error) {
	rsp, err := c.PostBuild(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBuildResponse(rsp)
}

// PostBuildPlatformPackageWithBodyWithResponse request with arbitrary body returning *PostBuildPlatformPackageResponse
func (c *ClientWithResponses) PostBuildPlatformPackageWithBodyWithResponse(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBuildPlatformPackageResponse, error) {
	rsp, err := c.PostBuildPlatformPackageWithBody(ctx, platform, pPackage, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBuildPlatformPackageResponse(rsp)
}

func (c *ClientWithResponses) PostBuildPlatformPackageWithResponse(ctx context.Context, platform PostBuildPlatformPackageParamsPlatform, pPackage string, params *PostBuildPlatformPackageParams, body PostBuildPlatformPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBuildPlatformPackageResponse, error) {
	rsp, err := c.PostBuildPlatformPackage(ctx, platform, pPackage, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBuildPlatformPackageResponse(rsp)
}

// PostLoginTokenWithResponse request returning *PostLoginTokenResponse
func (c *ClientWithResponses) PostLoginTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostLoginTokenResponse, error) {
	rsp, err := c.PostLoginToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLoginTokenResponse(rsp)
}

// PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefWithResponse request returning *PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse
func (c *ClientWithResponses) PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefWithResponse(ctx context.Context, appRef openapi_types.UUID, currentGroupRef openapi_types.UUID, newGroupRef openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse, error) {
	rsp, err := c.PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRef(ctx, appRef, currentGroupRef, newGroupRef, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse(rsp)
}

// GetUserTokenWithResponse request returning *GetUserTokenResponse
func (c *ClientWithResponses) GetUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserTokenResponse, error) {
	rsp, err := c.GetUserToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTokenResponse(rsp)
}

// PostUserTokenWithBodyWithResponse request with arbitrary body returning *PostUserTokenResponse
func (c *ClientWithResponses) PostUserTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTokenResponse, error) {
	rsp, err := c.PostUserTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTokenResponse(rsp)
}

func (c *ClientWithResponses) PostUserTokenWithResponse(ctx context.Context, body PostUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTokenResponse, error) {
	rsp, err := c.PostUserToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTokenResponse(rsp)
}

// PostUserTokenRefreshWithBodyWithResponse request with arbitrary body returning *PostUserTokenRefreshResponse
func (c *ClientWithResponses) PostUserTokenRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserTokenRefreshResponse, error) {
	rsp, err := c.PostUserTokenRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTokenRefreshResponse(rsp)
}

func (c *ClientWithResponses) PostUserTokenRefreshWithResponse(ctx context.Context, body PostUserTokenRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserTokenRefreshResponse, error) {
	rsp, err := c.PostUserTokenRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserTokenRefreshResponse(rsp)
}

// ParseGetAccountUserResponse parses an HTTP response from a GetAccountUserWithResponse call
func ParseGetAccountUserResponse(rsp *http.Response) (*GetAccountUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []struct {
			// Active The active state of the user.
			Active bool `json:"active"`

			// AllCapabilities The list of capabilities available to the user.
			AllCapabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"all_capabilities"`

			// AvatarUrl The URL of the user's avatar image.
			AvatarUrl    *string       `json:"avatar_url"`
			Capabilities []interface{} `json:"capabilities"`

			// CreatedAt The date-time the user was created.
			CreatedAt time.Time `json:"created_at"`

			// Email The email address of the user.
			Email *string `json:"email"`

			// GroupRefs The UUID refs for the groups the user was added to when they were invited.
			GroupRefs *[]openapi_types.UUID `json:"groupRefs"`

			// Groups The list of groups the user is a member of.
			Groups []struct {
				// Active The active state of the group.
				Active bool `json:"active"`

				// CreatedAt The date-time the group was created.
				CreatedAt time.Time `json:"createdAt"`

				// DeletedAt The date-time this group was soft-deleted.
				DeletedAt time.Time `json:"deleted_at"`

				// Id The unique numeric identifier for the group.
				Id int `json:"id"`

				// Name The name of the group.
				Name string `json:"name"`

				// Note An optional note assigned to the group.
				Note *string `json:"note"`

				// OrganizationId The numeric ID of the organization this group belongs to.
				OrganizationId int `json:"organizationId"`

				// Ref The unique identifier for the group.
				Ref openapi_types.UUID `json:"ref"`

				// UpdatedAt The date-time this group was last updated.
				UpdatedAt time.Time `json:"updatedAt"`

				// UpdatedBy The UUID ref of the user who last updated this group.
				UpdatedBy *openapi_types.UUID `json:"updated_by"`
			} `json:"groups"`

			// Id The unique numeric identifier for the user.
			Id int `json:"id"`

			// Name The name of the user.
			Name string `json:"name"`

			// Note An optional note assigned to the user.
			Note *string `json:"note"`

			// OrganizationId The numeric ID of the organization the user belongs to.
			OrganizationId int `json:"organizationId"`

			// Privileges The list of permission strings for the capabilities available to the user.
			Privileges []string `json:"privileges"`

			// Ref The unique identifier for the user.
			Ref openapi_types.UUID `json:"ref"`

			// RoleRef The UUID ref of the role the user was assigned when they were invited.
			RoleRef *openapi_types.UUID `json:"roleRef"`

			// Roles The list of roles assigned to the user.
			Roles []struct {
				// AllCapabilities The list of capabilities available to this role.
				AllCapabilities []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"all_capabilities"`

				// Capabilities The list of capabilities available to this role.
				Capabilities []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"capabilities"`

				// CreatedAt The date-time the role was created.
				CreatedAt time.Time `json:"created_at"`

				// DefaultLabel A short descriptive label for the role.
				DefaultLabel *string `json:"defaultLabel"`

				// DefaultPermissions The list of capabilities available to this role by default.
				DefaultPermissions []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"defaultPermissions"`

				// Description A short description of the role.
				Description *string `json:"description"`

				// Id The unique numeric identifier for the role.
				Id           int   `json:"id"`
				IsCustomized *bool `json:"isCustomized,omitempty"`

				// IsHidden Determines if the role is hidden.
				IsHidden *bool `json:"isHidden"`

				// IsCustomizable Determines if the role can be customized.
				IsCustomizable *bool `json:"is_customizable"`

				// IsInternal Determines if the role is internal.
				IsInternal *bool `json:"is_internal"`

				// Label A short descriptive label for the role.
				Label *string `json:"label"`

				// Name The name of the role.
				Name string `json:"name"`

				// OrgSettings The list of organization-level settings associated with this role.
				OrgSettings []map[string]interface{} `json:"org_settings"`

				// OrganizationCapabilities For a customized role, the list of capabilities available to this role.
				OrganizationCapabilities []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"organization_capabilities"`

				// OrganizationId The numeric ID of the organization this group belongs to.
				OrganizationId *int `json:"organization_id"`

				// Permissions The list of capabilities available to this role.
				Permissions []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"permissions"`

				// Ref The unique identifier for the role.
				Ref openapi_types.UUID `json:"ref"`

				// UpdatedAt The date-time the role was last updated.
				UpdatedAt time.Time `json:"updated_at"`
			} `json:"roles"`

			// UpdatedAt The date-time the user was last updated.
			UpdatedAt time.Time `json:"updated_at"`

			// UpdatedBy The UUID ref of user who last updated the user.
			UpdatedBy *openapi_types.UUID `json:"updated_by"`

			// Username The username of the user.
			Username *string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAccountUserRefResponse parses an HTTP response from a GetAccountUserRefWithResponse call
func ParseGetAccountUserRefResponse(rsp *http.Response) (*GetAccountUserRefResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountUserRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Active The active state of the user.
			Active bool `json:"active"`

			// AllCapabilities The list of capabilities available to the user.
			AllCapabilities []struct {
				// Actions The verb actions this capability grants.
				Actions []string `json:"actions"`

				// Category The category grouping of the capability.
				Category *string `json:"category"`

				// CreatedAt The date-time this capability was created.
				CreatedAt time.Time `json:"createdAt"`

				// Id The unique numeric identifier for the capability.
				Id int `json:"id"`

				// Label The short descriptive label for the capability.
				Label string `json:"label"`

				// Namespace The wider grouping of the resource this capability relates to.
				Namespace string `json:"namespace"`

				// Privileges The list of privileges granted by this capability.
				Privileges []string `json:"privileges"`

				// Ref The unique identifier for the capability.
				Ref openapi_types.UUID `json:"ref"`

				// ResourceType The type of entity/resource this capability relates to.
				ResourceType string `json:"resource_type"`

				// Scope The level of access this capability grants to the resource it relates to.
				Scope *string `json:"scope"`

				// UpdatedAt The date-time this capability was last updated.
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"all_capabilities"`

			// AvatarUrl The URL of the user's avatar image.
			AvatarUrl    *string       `json:"avatar_url"`
			Capabilities []interface{} `json:"capabilities"`

			// CreatedAt The date-time the user was created.
			CreatedAt time.Time `json:"created_at"`

			// Email The email address of the user.
			Email *string `json:"email"`

			// GroupRefs The UUID refs for the groups the user was added to when they were invited.
			GroupRefs *[]openapi_types.UUID `json:"groupRefs"`

			// Groups The list of groups the user is a member of.
			Groups []struct {
				// Active The active state of the group.
				Active bool `json:"active"`

				// CreatedAt The date-time the group was created.
				CreatedAt time.Time `json:"createdAt"`

				// DeletedAt The date-time this group was soft-deleted.
				DeletedAt time.Time `json:"deleted_at"`

				// Id The unique numeric identifier for the group.
				Id int `json:"id"`

				// Name The name of the group.
				Name string `json:"name"`

				// Note An optional note assigned to the group.
				Note *string `json:"note"`

				// OrganizationId The numeric ID of the organization this group belongs to.
				OrganizationId int `json:"organizationId"`

				// Ref The unique identifier for the group.
				Ref openapi_types.UUID `json:"ref"`

				// UpdatedAt The date-time this group was last updated.
				UpdatedAt time.Time `json:"updatedAt"`

				// UpdatedBy The UUID ref of the user who last updated this group.
				UpdatedBy *openapi_types.UUID `json:"updated_by"`
			} `json:"groups"`

			// Id The unique numeric identifier for the user.
			Id int `json:"id"`

			// Name The name of the user.
			Name string `json:"name"`

			// Note An optional note assigned to the user.
			Note *string `json:"note"`

			// OrganizationId The numeric ID of the organization the user belongs to.
			OrganizationId int `json:"organizationId"`

			// Privileges The list of permission strings for the capabilities available to the user.
			Privileges []string `json:"privileges"`

			// Ref The unique identifier for the user.
			Ref openapi_types.UUID `json:"ref"`

			// RoleRef The UUID ref of the role the user was assigned when they were invited.
			RoleRef *openapi_types.UUID `json:"roleRef"`

			// Roles The list of roles assigned to the user.
			Roles []struct {
				// AllCapabilities The list of capabilities available to this role.
				AllCapabilities []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"all_capabilities"`

				// Capabilities The list of capabilities available to this role.
				Capabilities []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"capabilities"`

				// CreatedAt The date-time the role was created.
				CreatedAt time.Time `json:"created_at"`

				// DefaultLabel A short descriptive label for the role.
				DefaultLabel *string `json:"defaultLabel"`

				// DefaultPermissions The list of capabilities available to this role by default.
				DefaultPermissions []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"defaultPermissions"`

				// Description A short description of the role.
				Description *string `json:"description"`

				// Id The unique numeric identifier for the role.
				Id           int   `json:"id"`
				IsCustomized *bool `json:"isCustomized,omitempty"`

				// IsHidden Determines if the role is hidden.
				IsHidden *bool `json:"isHidden"`

				// IsCustomizable Determines if the role can be customized.
				IsCustomizable *bool `json:"is_customizable"`

				// IsInternal Determines if the role is internal.
				IsInternal *bool `json:"is_internal"`

				// Label A short descriptive label for the role.
				Label *string `json:"label"`

				// Name The name of the role.
				Name string `json:"name"`

				// OrgSettings The list of organization-level settings associated with this role.
				OrgSettings []map[string]interface{} `json:"org_settings"`

				// OrganizationCapabilities For a customized role, the list of capabilities available to this role.
				OrganizationCapabilities []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"organization_capabilities"`

				// OrganizationId The numeric ID of the organization this group belongs to.
				OrganizationId *int `json:"organization_id"`

				// Permissions The list of capabilities available to this role.
				Permissions []struct {
					// Actions The verb actions this capability grants.
					Actions []string `json:"actions"`

					// Category The category grouping of the capability.
					Category *string `json:"category"`

					// CreatedAt The date-time this capability was created.
					CreatedAt time.Time `json:"createdAt"`

					// Id The unique numeric identifier for the capability.
					Id int `json:"id"`

					// Label The short descriptive label for the capability.
					Label string `json:"label"`

					// Namespace The wider grouping of the resource this capability relates to.
					Namespace string `json:"namespace"`

					// Privileges The list of privileges granted by this capability.
					Privileges []string `json:"privileges"`

					// Ref The unique identifier for the capability.
					Ref openapi_types.UUID `json:"ref"`

					// ResourceType The type of entity/resource this capability relates to.
					ResourceType string `json:"resource_type"`

					// Scope The level of access this capability grants to the resource it relates to.
					Scope *string `json:"scope"`

					// UpdatedAt The date-time this capability was last updated.
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"permissions"`

				// Ref The unique identifier for the role.
				Ref openapi_types.UUID `json:"ref"`

				// UpdatedAt The date-time the role was last updated.
				UpdatedAt time.Time `json:"updated_at"`
			} `json:"roles"`

			// UpdatedAt The date-time the user was last updated.
			UpdatedAt time.Time `json:"updated_at"`

			// UpdatedBy The UUID ref of user who last updated the user.
			UpdatedBy *openapi_types.UUID `json:"updated_by"`

			// Username The username of the user.
			Username *string `json:"username"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []LabApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostAppResponse parses an HTTP response from a PostAppWithResponse call
func ParsePostAppResponse(rsp *http.Response) (*PostAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest LabApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageResponse parses an HTTP response from a GetAppPlatformPackageWithResponse call
func ParseGetAppPlatformPackageResponse(rsp *http.Response) (*GetAppPlatformPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest LabApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageAssessmentResponse parses an HTTP response from a GetAppPlatformPackageAssessmentWithResponse call
func ParseGetAppPlatformPackageAssessmentResponse(rsp *http.Response) (*GetAppPlatformPackageAssessmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageAssessmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []struct {
			// Account The UUID ref of the group this assessment belongs to.
			Account *openapi_types.UUID `json:"account"`

			// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
			AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

			// AdjustedScore The score for the user-edited assessment report.
			AdjustedScore *float32 `json:"adjusted_score"`

			// Application The UUID ref of the application this assessment belongs to.
			Application *openapi_types.UUID `json:"application"`

			// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
			AppstoreDownload *GetAppPlatformPackageAssessment2XXAppstoreDownload `json:"appstore_download,omitempty"`

			// Binary The SHA-256 hash of the binary this assessment was run on.
			Binary *string `json:"binary"`

			// Cancelled Whether this assessment was manually cancelled before completion.
			Cancelled bool `json:"cancelled"`

			// Config The complete configuration this assessment was ran with.
			Config struct {
				// Dynamic The dynamic-specific configuration this assessment was ran with.
				Dynamic interface{} `json:"dynamic"`

				// Static The static-specific configuration this assessment was ran with.
				Static interface{} `json:"static"`
			} `json:"config"`

			// Created The date-time this assessment was created.
			Created *time.Time `json:"created"`

			// Creator The UUID ref of the user who triggered this assessment.
			Creator *openapi_types.UUID `json:"creator"`
			Events  struct {
				Dynamic []interface{} `json:"dynamic"`
			} `json:"events"`

			// Favorite Whether this assessment has been marked as a favorite.
			Favorite *bool `json:"favorite"`

			// Group The UUID ref of the group this assessment belongs to.
			Group *openapi_types.UUID `json:"group"`

			// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
			IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

			// Package The package ID of the application this assessment belongs to.
			Package string `json:"package"`

			// Platform The operating system of the application this assessment belongs to (android or ios).
			Platform string `json:"platform"`

			// Ref The unique identifier for the assessment.
			Ref openapi_types.UUID `json:"ref"`

			// Status An object describing the status of the static and dynamic tasks associated with this assessment.
			Status struct {
				// Dynamic A string describing the status of the dynamic task associated with this assessment.
				Dynamic interface{} `json:"dynamic"`

				// Static A string describing the status of the static task associated with this assessment.
				Static interface{} `json:"static"`
			} `json:"status"`

			// Task An integer identifying the underlying analysis tasks associated with this assessment.
			Task float32 `json:"task"`

			// TaskErrorCode The error code describing the failure if an assessment failed.
			TaskErrorCode *string `json:"task_error_code"`

			// TaskStatus The state of the assessment.
			TaskStatus *GetAppPlatformPackageAssessment2XXTaskStatus `json:"task_status,omitempty"`

			// Updated The date-time this assessment was last updated.
			Updated *time.Time `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostAppPlatformPackageAssessmentResponse parses an HTTP response from a PostAppPlatformPackageAssessmentWithResponse call
func ParsePostAppPlatformPackageAssessmentResponse(rsp *http.Response) (*PostAppPlatformPackageAssessmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppPlatformPackageAssessmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Account The UUID ref of the group this assessment belongs to.
			Account *openapi_types.UUID `json:"account"`

			// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
			AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

			// AdjustedScore The score for the user-edited assessment report.
			AdjustedScore *float32 `json:"adjusted_score"`

			// Application The UUID ref of the application this assessment belongs to.
			Application *openapi_types.UUID `json:"application"`

			// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
			AppstoreDownload *PostAppPlatformPackageAssessment2XXAppstoreDownload `json:"appstore_download,omitempty"`

			// Binary The SHA-256 hash of the binary this assessment was run on.
			Binary *string `json:"binary"`

			// Cancelled Whether this assessment was manually cancelled before completion.
			Cancelled bool `json:"cancelled"`

			// Config The complete configuration this assessment was ran with.
			Config struct {
				// Dynamic The dynamic-specific configuration this assessment was ran with.
				Dynamic interface{} `json:"dynamic"`

				// Static The static-specific configuration this assessment was ran with.
				Static interface{} `json:"static"`
			} `json:"config"`

			// Created The date-time this assessment was created.
			Created *time.Time `json:"created"`

			// Creator The UUID ref of the user who triggered this assessment.
			Creator *openapi_types.UUID `json:"creator"`
			Events  struct {
				Dynamic []interface{} `json:"dynamic"`
			} `json:"events"`

			// Favorite Whether this assessment has been marked as a favorite.
			Favorite *bool `json:"favorite"`

			// Group The UUID ref of the group this assessment belongs to.
			Group *openapi_types.UUID `json:"group"`

			// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
			IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

			// Package The package ID of the application this assessment belongs to.
			Package string `json:"package"`

			// Platform The operating system of the application this assessment belongs to (android or ios).
			Platform string `json:"platform"`

			// Ref The unique identifier for the assessment.
			Ref openapi_types.UUID `json:"ref"`

			// Status An object describing the status of the static and dynamic tasks associated with this assessment.
			Status struct {
				// Dynamic A string describing the status of the dynamic task associated with this assessment.
				Dynamic interface{} `json:"dynamic"`

				// Static A string describing the status of the static task associated with this assessment.
				Static interface{} `json:"static"`
			} `json:"status"`

			// Task An integer identifying the underlying analysis tasks associated with this assessment.
			Task float64 `json:"task"`

			// TaskErrorCode The error code describing the failure if an assessment failed.
			TaskErrorCode *string `json:"task_error_code"`

			// TaskStatus The state of the assessment.
			TaskStatus *PostAppPlatformPackageAssessment2XXTaskStatus `json:"task_status,omitempty"`

			// Updated The date-time this assessment was last updated.
			Updated *time.Time `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageAssessmentTaskResponse parses an HTTP response from a GetAppPlatformPackageAssessmentTaskWithResponse call
func ParseGetAppPlatformPackageAssessmentTaskResponse(rsp *http.Response) (*GetAppPlatformPackageAssessmentTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageAssessmentTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Account The UUID ref of the group this assessment belongs to.
			Account *openapi_types.UUID `json:"account"`

			// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
			AdjustedIssues *interface{} `json:"adjusted_issues,omitempty"`

			// AdjustedScore The score for the user-edited assessment report.
			AdjustedScore *float32 `json:"adjusted_score"`

			// Application The UUID ref of the application this assessment belongs to.
			Application *openapi_types.UUID `json:"application"`

			// AppstoreDownload * if the assessment was ran on the latest app store binary at the time of assessment.
			AppstoreDownload *GetAppPlatformPackageAssessmentTask2XXAppstoreDownload `json:"appstore_download,omitempty"`

			// Binary The SHA-256 hash of the binary this assessment was run on.
			Binary *string `json:"binary"`

			// Cancelled Whether this assessment was manually cancelled before completion.
			Cancelled bool `json:"cancelled"`

			// Config The complete configuration this assessment was ran with.
			Config struct {
				// Dynamic The dynamic-specific configuration this assessment was ran with.
				Dynamic interface{} `json:"dynamic"`

				// Static The static-specific configuration this assessment was ran with.
				Static interface{} `json:"static"`
			} `json:"config"`

			// Created The date-time this assessment was created.
			Created *time.Time `json:"created"`

			// Creator The UUID ref of the user who triggered this assessment.
			Creator *openapi_types.UUID `json:"creator"`
			Events  struct {
				Dynamic []interface{} `json:"dynamic"`
			} `json:"events"`

			// Favorite Whether this assessment has been marked as a favorite.
			Favorite *bool `json:"favorite"`

			// Group The UUID ref of the group this assessment belongs to.
			Group *openapi_types.UUID `json:"group"`

			// IdentifiedVulnMap A map from finding keys to integer identified vulnerability IDs.
			IdentifiedVulnMap *interface{} `json:"identified_vuln_map,omitempty"`

			// Package The package ID of the application this assessment belongs to.
			Package string `json:"package"`

			// Platform The operating system of the application this assessment belongs to (android or ios).
			Platform string `json:"platform"`

			// Ref The unique identifier for the assessment.
			Ref openapi_types.UUID `json:"ref"`

			// Status An object describing the status of the static and dynamic tasks associated with this assessment.
			Status struct {
				// Dynamic A string describing the status of the dynamic task associated with this assessment.
				Dynamic interface{} `json:"dynamic"`

				// Static A string describing the status of the static task associated with this assessment.
				Static interface{} `json:"static"`
			} `json:"status"`

			// Task An integer identifying the underlying analysis tasks associated with this assessment.
			Task float32 `json:"task"`

			// TaskErrorCode The error code describing the failure if an assessment failed.
			TaskErrorCode *string `json:"task_error_code"`

			// TaskStatus The state of the assessment.
			TaskStatus *GetAppPlatformPackageAssessmentTask2XXTaskStatus `json:"task_status,omitempty"`

			// Updated The date-time this assessment was last updated.
			Updated *time.Time `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageAssessmentTaskRawResponse parses an HTTP response from a GetAppPlatformPackageAssessmentTaskRawWithResponse call
func ParseGetAppPlatformPackageAssessmentTaskRawResponse(rsp *http.Response) (*GetAppPlatformPackageAssessmentTaskRawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageAssessmentTaskRawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Dynamic The raw dynamic analysis results for the assessment.
			Dynamic *map[string]interface{} `json:"dynamic,omitempty"`

			// Static The raw static analysis results for the assessment.
			Static *map[string]interface{} `json:"static,omitempty"`

			// Yaap The raw YaapStatic analysis results for the assessment.
			Yaap *map[string]interface{} `json:"yaap,omitempty"`

			// YaapFiltered The raw YaapFilter analysis results for the assessment.
			YaapFiltered *map[string]interface{} `json:"yaap_filtered,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostAppPlatformPackageAssessmentTaskCancelResponse parses an HTTP response from a PostAppPlatformPackageAssessmentTaskCancelWithResponse call
func ParsePostAppPlatformPackageAssessmentTaskCancelResponse(rsp *http.Response) (*PostAppPlatformPackageAssessmentTaskCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppPlatformPackageAssessmentTaskCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Status The state of the assessment.
			Status PostAppPlatformPackageAssessmentTaskCancel2XXStatus `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageAssessmentTaskReportResponse parses an HTTP response from a GetAppPlatformPackageAssessmentTaskReportWithResponse call
func ParseGetAppPlatformPackageAssessmentTaskReportResponse(rsp *http.Response) (*GetAppPlatformPackageAssessmentTaskReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageAssessmentTaskReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Dynamic The raw dynamic analysis results for the assessment.
			Dynamic *map[string]interface{} `json:"dynamic,omitempty"`

			// Static The raw static analysis results for the assessment.
			Static *map[string]interface{} `json:"static,omitempty"`

			// Yaap The raw YaapStatic analysis results for the assessment.
			Yaap *map[string]interface{} `json:"yaap,omitempty"`

			// YaapFiltered The raw YaapFilter analysis results for the assessment.
			YaapFiltered *map[string]interface{} `json:"yaap_filtered,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageAssessmentTaskResultsResponse parses an HTTP response from a GetAppPlatformPackageAssessmentTaskResultsWithResponse call
func ParseGetAppPlatformPackageAssessmentTaskResultsResponse(rsp *http.Response) (*GetAppPlatformPackageAssessmentTaskResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageAssessmentTaskResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostAppPlatformPackageBinaryResponse parses an HTTP response from a PostAppPlatformPackageBinaryWithResponse call
func ParsePostAppPlatformPackageBinaryResponse(rsp *http.Response) (*PostAppPlatformPackageBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppPlatformPackageBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Account Deprecated. Use group instead.
			Account openapi_types.UUID `json:"account"`

			// Analyzed True if the last analysis of this application has completed.
			Analyzed *bool `json:"analyzed,omitempty"`

			// Application The UUID ref of the application the build belongs to.
			Application openapi_types.UUID `json:"application"`

			// Created Creation date of the application record.
			Created time.Time `json:"created"`

			// Digest The SHA-256 digest of the analyzed binary. Note that some applications are repackaged prior to analysis, so this digest may differ from the digest of the uploaded file.
			Digest string `json:"digest"`

			// DownloadedAppstoreApplicationKey The App store / Play store key for applications downloaded from a store.
			DownloadedAppstoreApplicationKey *string `json:"downloaded_appstore_application_key,omitempty"`

			// Group The UUID identifier of the group this application belongs to.
			Group openapi_types.UUID `json:"group"`

			// Icon The icon of the application in base64 format.
			Icon *string `json:"icon,omitempty"`

			// Package The package or bundle ID.
			Package string `json:"package"`

			// Platform The operating system of the application (android or ios).
			Platform *string `json:"platform,omitempty"`

			// Ref The UUID identifier of the application binary.
			Ref openapi_types.UUID `json:"ref"`

			// Title The application title.
			Title *string `json:"title,omitempty"`

			// Uploaded The date-time the binary was uploaded.
			Uploaded *string `json:"uploaded,omitempty"`

			// Uploader The UUID identifier of the user who uploaded the application.
			Uploader *string `json:"uploader,omitempty"`

			// Version The application version string.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageBuildResponse parses an HTTP response from a GetAppPlatformPackageBuildWithResponse call
func ParseGetAppPlatformPackageBuildResponse(rsp *http.Response) (*GetAppPlatformPackageBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest AppBuildList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAppPlatformPackageConfigResponse parses an HTTP response from a GetAppPlatformPackageConfigWithResponse call
func ParseGetAppPlatformPackageConfigResponse(rsp *http.Response) (*GetAppPlatformPackageConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppPlatformPackageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Dynamic The dynamic configuration for the application.
			Dynamic      *map[string]interface{} `json:"dynamic,omitempty"`
			Integrations *struct {
				PENTEST *struct {
					Azure *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							ReferenceName string `json:"referenceName"`
							Type          string `json:"type"`
							Value         string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						OrganizationName     string                  `json:"organizationName"`
						ProjectId            string                  `json:"projectId"`
						Tags                 *[]string               `json:"tags,omitempty"`
						WorkItemType         string                  `json:"workItemType"`
					} `json:"azure,omitempty"`
					Github *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						Labels                    *[]string `json:"labels,omitempty"`
						Repository                string    `json:"repository"`
					} `json:"github,omitempty"`
					Gitlab *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
						GroupId                   string    `json:"groupId"`
						Labels                    *[]string `json:"labels,omitempty"`
						ProjectId                 string    `json:"projectId"`
					} `json:"gitlab,omitempty"`
					Jira *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						BaseUrl                   *string `json:"baseUrl,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							Name  string `json:"name"`
							Type  string `json:"type"`
							Value string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						IssueType            *string                 `json:"issueType,omitempty"`
						Labels               *[]string               `json:"labels,omitempty"`
						Project              string                  `json:"project"`
					} `json:"jira,omitempty"`
					Servicenow *struct {
						AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
						AutomationRules      struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CategorySysId             *string `json:"categorySysId,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
						ImpactLevel               *string `json:"impactLevel,omitempty"`
						UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
					} `json:"servicenow,omitempty"`
				} `json:"PEN_TEST,omitempty"`
				PLATFORM *struct {
					Azure *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							ReferenceName string `json:"referenceName"`
							Type          string `json:"type"`
							Value         string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						OrganizationName     string                  `json:"organizationName"`
						ProjectId            string                  `json:"projectId"`
						Tags                 *[]string               `json:"tags,omitempty"`
						WorkItemType         string                  `json:"workItemType"`
					} `json:"azure,omitempty"`
					Github *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						Labels                    *[]string `json:"labels,omitempty"`
						Repository                string    `json:"repository"`
					} `json:"github,omitempty"`
					Gitlab *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
						GroupId                   string    `json:"groupId"`
						Labels                    *[]string `json:"labels,omitempty"`
						ProjectId                 string    `json:"projectId"`
					} `json:"gitlab,omitempty"`
					Jira *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						BaseUrl                   *string `json:"baseUrl,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							Name  string `json:"name"`
							Type  string `json:"type"`
							Value string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						IssueType            *string                 `json:"issueType,omitempty"`
						Labels               *[]string               `json:"labels,omitempty"`
						Project              string                  `json:"project"`
					} `json:"jira,omitempty"`
					Servicenow *struct {
						AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
						AutomationRules      struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CategorySysId             *string `json:"categorySysId,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
						ImpactLevel               *string `json:"impactLevel,omitempty"`
						UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
					} `json:"servicenow,omitempty"`
				} `json:"PLATFORM,omitempty"`
			} `json:"integrations,omitempty"`

			// Static The static configuration for the application.
			Static *map[string]interface{} `json:"static,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostAppPlatformPackageConfigResponse parses an HTTP response from a PostAppPlatformPackageConfigWithResponse call
func ParsePostAppPlatformPackageConfigResponse(rsp *http.Response) (*PostAppPlatformPackageConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppPlatformPackageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Dynamic The dynamic configuration for the application.
			Dynamic      *map[string]interface{} `json:"dynamic,omitempty"`
			Integrations *struct {
				PENTEST *struct {
					Azure *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							ReferenceName string `json:"referenceName"`
							Type          string `json:"type"`
							Value         string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						OrganizationName     string                  `json:"organizationName"`
						ProjectId            string                  `json:"projectId"`
						Tags                 *[]string               `json:"tags,omitempty"`
						WorkItemType         string                  `json:"workItemType"`
					} `json:"azure,omitempty"`
					Github *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						Labels                    *[]string `json:"labels,omitempty"`
						Repository                string    `json:"repository"`
					} `json:"github,omitempty"`
					Gitlab *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
						GroupId                   string    `json:"groupId"`
						Labels                    *[]string `json:"labels,omitempty"`
						ProjectId                 string    `json:"projectId"`
					} `json:"gitlab,omitempty"`
					Jira *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						BaseUrl                   *string `json:"baseUrl,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							Name  string `json:"name"`
							Type  string `json:"type"`
							Value string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						IssueType            *string                 `json:"issueType,omitempty"`
						Labels               *[]string               `json:"labels,omitempty"`
						Project              string                  `json:"project"`
					} `json:"jira,omitempty"`
					Servicenow *struct {
						AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
						AutomationRules      struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CategorySysId             *string `json:"categorySysId,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
						ImpactLevel               *string `json:"impactLevel,omitempty"`
						UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
					} `json:"servicenow,omitempty"`
				} `json:"PEN_TEST,omitempty"`
				PLATFORM *struct {
					Azure *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							ReferenceName string `json:"referenceName"`
							Type          string `json:"type"`
							Value         string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						OrganizationName     string                  `json:"organizationName"`
						ProjectId            string                  `json:"projectId"`
						Tags                 *[]string               `json:"tags,omitempty"`
						WorkItemType         string                  `json:"workItemType"`
					} `json:"azure,omitempty"`
					Github *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						Labels                    *[]string `json:"labels,omitempty"`
						Repository                string    `json:"repository"`
					} `json:"github,omitempty"`
					Gitlab *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CreateIssuesAutomatically *bool     `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool     `json:"excludeEvidence,omitempty"`
						GroupId                   string    `json:"groupId"`
						Labels                    *[]string `json:"labels,omitempty"`
						ProjectId                 string    `json:"projectId"`
					} `json:"gitlab,omitempty"`
					Jira *struct {
						AutomationRules struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						BaseUrl                   *string `json:"baseUrl,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						CustomFields              *[]struct {
							Name  string `json:"name"`
							Type  string `json:"type"`
							Value string `json:"value"`
						} `json:"customFields,omitempty"`
						ExcludeEvidence      *bool                   `json:"excludeEvidence,omitempty"`
						IssueTemplateMapping *map[string]interface{} `json:"issueTemplateMapping,omitempty"`
						IssueType            *string                 `json:"issueType,omitempty"`
						Labels               *[]string               `json:"labels,omitempty"`
						Project              string                  `json:"project"`
					} `json:"jira,omitempty"`
					Servicenow *struct {
						AssignmentGroupSysId *string `json:"assignmentGroupSysId,omitempty"`
						AutomationRules      struct {
							PolicyCategories *struct {
								Category1 bool `json:"category1"`
								Category2 bool `json:"category2"`
								Category3 bool `json:"category3"`
							} `json:"policyCategories,omitempty"`
							Severities *struct {
								Critical bool `json:"critical"`
								High     bool `json:"high"`
								Info     bool `json:"info"`
								Low      bool `json:"low"`
								Medium   bool `json:"medium"`
								Warn     bool `json:"warn"`
							} `json:"severities,omitempty"`
						} `json:"automationRules"`
						CategorySysId             *string `json:"categorySysId,omitempty"`
						CreateIssuesAutomatically *bool   `json:"createIssuesAutomatically,omitempty"`
						ExcludeEvidence           *bool   `json:"excludeEvidence,omitempty"`
						ImpactLevel               *string `json:"impactLevel,omitempty"`
						UrgencyLevel              *string `json:"urgencyLevel,omitempty"`
					} `json:"servicenow,omitempty"`
				} `json:"PLATFORM,omitempty"`
			} `json:"integrations,omitempty"`

			// Static The static configuration for the application.
			Static *map[string]interface{} `json:"static,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteAppPlatformPackageRunnerResponse parses an HTTP response from a DeleteAppPlatformPackageRunnerWithResponse call
func ParseDeleteAppPlatformPackageRunnerResponse(rsp *http.Response) (*DeleteAppPlatformPackageRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppPlatformPackageRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest LabApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostAppPlatformPackageRunnerResponse parses an HTTP response from a PostAppPlatformPackageRunnerWithResponse call
func ParsePostAppPlatformPackageRunnerResponse(rsp *http.Response) (*PostAppPlatformPackageRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppPlatformPackageRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest LabApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAssessmentRefReportHtmlResponse parses an HTTP response from a GetAssessmentRefReportHtmlWithResponse call
func ParseGetAssessmentRefReportHtmlResponse(rsp *http.Response) (*GetAssessmentRefReportHtmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssessmentRefReportHtmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAssessmentRefReportJsonResponse parses an HTTP response from a GetAssessmentRefReportJsonWithResponse call
func ParseGetAssessmentRefReportJsonResponse(rsp *http.Response) (*GetAssessmentRefReportJsonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssessmentRefReportJsonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAssessmentRefReportPdfResponse parses an HTTP response from a GetAssessmentRefReportPdfWithResponse call
func ParseGetAssessmentRefReportPdfResponse(rsp *http.Response) (*GetAssessmentRefReportPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssessmentRefReportPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAssessmentTaskFindingsResponse parses an HTTP response from a GetAssessmentTaskFindingsWithResponse call
func ParseGetAssessmentTaskFindingsResponse(rsp *http.Response) (*GetAssessmentTaskFindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssessmentTaskFindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []GetAssessmentTaskFindings_2XX_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetAssessmentTaskSummaryResponse parses an HTTP response from a GetAssessmentTaskSummaryWithResponse call
func ParseGetAssessmentTaskSummaryResponse(rsp *http.Response) (*GetAssessmentTaskSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssessmentTaskSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// AdjustedIssues A map from finding keys to the finding's associated CVSS score in the user-edited assessment report.
			AdjustedIssues interface{} `json:"adjusted_issues"`

			// BaseScore The score for the unedited assessment report.
			BaseScore *float32 `json:"base_score"`

			// Changes An object associating user-made overrides to findings by their key.
			Changes     interface{}                             `json:"changes"`
			CvssVersion *GetAssessmentTaskSummary2XXCvssVersion `json:"cvss_version"`

			// FindingsDigest A digest identifying the findings version used for this assessment report.
			FindingsDigest *string `json:"findings_digest"`

			// Issues A map from finding keys to the finding's associated CVSS score in the unedited assessment report.
			Issues interface{} `json:"issues"`

			// Score The score for the user-edited assessment report.
			Score *float32 `json:"score"`

			// Status The state of the assessment.
			Status GetAssessmentTaskSummary2XXStatus `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostBinaryResponse parses an HTTP response from a PostBinaryWithResponse call
func ParsePostBinaryResponse(rsp *http.Response) (*PostBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Algorithm The hashing algorithm used to generate the binary digest.
			Algorithm *string `json:"algorithm"`

			// Analyzed Whether the binary has been analyzed.
			Analyzed *bool `json:"analyzed"`

			// Digest The hash digest of the binary file.
			Digest string `json:"digest"`

			// DownloadedAppstoreApplicationKey The iOS application store ID or Android package name for the app binary as it exists in the app store.
			DownloadedAppstoreApplicationKey *string `json:"downloaded_appstore_application_key"`

			// Icon The Base64 encoded string for the binary's icon.
			Icon *string `json:"icon"`

			// Name The name of the application the binary is for.
			Name *string `json:"name"`

			// Package The iOS Bundle ID or Android package name for the binary.
			Package *string `json:"package"`

			// Platform The Platform (ios/android) of the binary.
			Platform *string `json:"platform"`

			// Title The title of the application the binary is for.
			Title *string `json:"title"`
			Token *string `json:"token"`

			// UploadRef The unique identifier for the upload record associated with this binary.
			UploadRef *openapi_types.UUID `json:"uploadRef,omitempty"`

			// Version The application version of the binary.
			Version *string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetBinaryDigestAnalysisResponse parses an HTTP response from a GetBinaryDigestAnalysisWithResponse call
func ParseGetBinaryDigestAnalysisResponse(rsp *http.Response) (*GetBinaryDigestAnalysisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinaryDigestAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []GetBinaryDigestAnalysis_2XX_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetBuildResponse parses an HTTP response from a GetBuildWithResponse call
func ParseGetBuildResponse(rsp *http.Response) (*GetBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest AppBuildList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostBuildResponse parses an HTTP response from a PostBuildWithResponse call
func ParsePostBuildResponse(rsp *http.Response) (*PostBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostBuildPlatformPackageResponse parses an HTTP response from a PostBuildPlatformPackageWithResponse call
func ParsePostBuildPlatformPackageResponse(rsp *http.Response) (*PostBuildPlatformPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBuildPlatformPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Binary The SHA-256 digest of the analyzed binary. Note that some applications are repackaged prior to analysis, so this digest may differ from the digest of the uploaded file.
			Binary string `json:"binary"`

			// Group The UUID identifier of the group this application belongs to.
			Group openapi_types.UUID `json:"group"`

			// Package The package or bundle ID.
			Package string `json:"package"`

			// Platform The operating system of the application (android or ios).
			Platform *string `json:"platform,omitempty"`

			// Version The application version string.
			Version              *string                `json:"version,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostLoginTokenResponse parses an HTTP response from a PostLoginTokenWithResponse call
func ParsePostLoginTokenResponse(rsp *http.Response) (*PostLoginTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLoginTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest ActionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse parses an HTTP response from a PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefWithResponse call
func ParsePostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse(rsp *http.Response) (*PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostResourceChangeAppGroupAppRefFromCurrentGroupRefToNewGroupRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest LabRouteError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUserTokenResponse parses an HTTP response from a GetUserTokenWithResponse call
func ParseGetUserTokenResponse(rsp *http.Response) (*GetUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []struct {
			// Exp Expires at
			Exp *float32 `json:"exp,omitempty"`

			// Iat Issued at
			Iat *float32 `json:"iat,omitempty"`

			// Iss Issuer
			Iss string `json:"iss"`

			// Jti jti/ref
			Jti openapi_types.UUID `json:"jti"`

			// Name Name
			Name *string `json:"name,omitempty"`

			// Sub User ref
			Sub openapi_types.UUID `json:"sub"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostUserTokenResponse parses an HTTP response from a PostUserTokenWithResponse call
func ParsePostUserTokenResponse(rsp *http.Response) (*PostUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Data struct {
				// Exp Expires at
				Exp float32 `json:"exp"`

				// Iat Issued at
				Iat float32 `json:"iat"`

				// Iss Issuer
				Iss string `json:"iss"`

				// Jti jti/ref
				Jti openapi_types.UUID `json:"jti"`

				// Name Name
				Name string `json:"name"`

				// Sub User ref
				Sub openapi_types.UUID `json:"sub"`
			} `json:"data"`
			Token string `json:"token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePostUserTokenRefreshResponse parses an HTTP response from a PostUserTokenRefreshWithResponse call
func ParsePostUserTokenRefreshResponse(rsp *http.Response) (*PostUserTokenRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserTokenRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Data struct {
				// Exp Expires at
				Exp float32 `json:"exp"`

				// Iat Issued at
				Iat float32 `json:"iat"`

				// Iss Issuer
				Iss string `json:"iss"`

				// Jti jti/ref
				Jti openapi_types.UUID `json:"jti"`

				// Name Name
				Name string `json:"name"`

				// Sub User ref
				Sub openapi_types.UUID `json:"sub"`
			} `json:"data"`
			Token string `json:"token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message string `json:"message"`
			Name    string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest StandardError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}
